---
title: 컴파일러 - 실행파일 구조
author: blakewoo
date: 2025-7-30 23:30:00 +0900
categories: [Compiler]
tags: [Computer science, Compiler, Exe, Elf, PE] 
render_with_liquid: false
use_math: true
---

# 실행파일 구조
## 1. 개요
우리가 프로그램을 사용할 때 많은 파일들을 접하고 윈도우의 경우 더블클릭으로 리눅스의 경우 명령어로 간단히 실행하지만   
실제로 실행하는 가능한 파일의 형태는 한정되어있다.   

## 2. PE FILE FORMAT (윈도우)

실제 파일의 구조를 나타내면 아래와 같다.

![img.png](/assets/blog/compiler/img.png)

세부적인 섹션 크기의 경우 파일에 따라 다르며, section header의 경우에도 어떤 섹션은 있고 어떤 섹션은 없는 식으로
달라질 수 있다.
오른쪽의 숫자는 offset으로 0번지부터 몇 개의 바이트로 이루어져있느냐를 말한다.


### 1) PE Header
DOS header 부터 Section header까지를 모두 더해서 PE HEADER라고 한다.

#### a. DOS header

```c
typedef struct _IMAGE_DOS_HEADER {     
    WORD   e_magic;          // DOS signature : 4D5A ("MZ")
    WORD   e_cblp;                    
    WORD   e_cp;                      
    WORD   e_crlc;                    
    WORD   e_cparhdr;                 
    WORD   e_minalloc;                
    WORD   e_maxalloc;                
    WORD   e_ss;                      
    WORD   e_sp;                      
    WORD   e_csum;                    
    WORD   e_ip;                      
    WORD   e_cs;                      
    WORD   e_lfarlc;                  
    WORD   e_ovno;                    
    WORD   e_res[4];                  
    WORD   e_oemid;                   
    WORD   e_oeminfo;                 
    WORD   e_res2[10];                  
    LONG   e_lfanew;         // offset to NT header 
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

제일 앞에 MZ 시그니처(DOS 실행파일 설계자인 Mark Zbikowski 의 이니셜)가 2바이트로 기재되어있으며 e_lfanew는 NT header가 어디부터 시작하는지 
offset을 가르키고 있다.

#### b. DOS stub
이 부분은 있어도 되고 없어도 되는 옵션부분이다. 사실 DOS stub은 없어도 실행간에는 아무런 문제가 없다.
다만 notepad.exe를 열어보면 이부분이 있는 것을 확인 할 수 있는데, DOS에서 실행시 "This program cannot be run in DOS mode"라고
출력되게 되어있다.

따라서 이 부분의 존재 유무는 개발툴에 의존한다.

#### c. NT header

```c
typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;                          // PE Signature : 50450000 ("PE"00)
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

NT 헤더는 처음에 PE 라는 시그니처를 4Bytes로 갖고 시작하며 그 아래로는 FileHeader와 OptionalHeader를 갖는다.
FileHeader의 구조체는 아래와 같다.

```c
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

여기서 중요한건 총 4가지 값이다.
- Machine : CPU 별로 고유한 값이있는데, 32 bit intel의 경우 0x014c, 64bit intel의 경우 0x0200을 갖는다.
- NumberOfSections : 총 세션의 개수이며, 코드, 데이터, 리소스 등이 각각 섹션에 나눠서 저장되기 때문에 최소 1 이상이다.
- sizeOfOptionalHeader : 실제 OptionalHeader의 크기는 정해져있지만 윈도우에서는 이 값을 가지고 OptionalHeader의 크기를 인식한다.
- Characteristic : 실행 가능한지 혹은 DLL 인지 bit OR로 조합되어있으며 내용은 아래와 같다.

| 값 (16진수) | 플래그 이름                               | 설명                          |
| -------- | ------------------------------------ | --------------------------- |
| 0x0001   | `IMAGE_FILE_RELOCS_STRIPPED`         | 재배치 정보(relocations)가 제거됨    |
| 0x0002   | `IMAGE_FILE_EXECUTABLE_IMAGE`        | 실행 가능한 이미지임                 |
| 0x0004   | `IMAGE_FILE_LINE_NUMS_STRIPPED`      | 라인 번호 정보(line numbers)가 제거됨 |
| 0x0008   | `IMAGE_FILE_LOCAL_SYMS_STRIPPED`     | 로컬 심볼(local symbols)이 제거됨   |
| 0x0010   | `IMAGE_FILE_AGGRESIVE_WS_TRIM`       | 워크셋(workset) 공격적 축소         |
| 0x0020   | `IMAGE_FILE_LARGE_ADDRESS_AWARE`     | 2 GB 초과 주소 공간을 사용할 수 있음     |
| 0x0080   | `IMAGE_FILE_BYTES_REVERSED_LO`       | 저(低) 바이트 순서가 뒤바뀜(사용 안 함)    |
| 0x0100   | `IMAGE_FILE_32BIT_MACHINE`           | 32비트 머신용                    |
| 0x0200   | `IMAGE_FILE_DEBUG_STRIPPED`          | 디버그 정보가 제거됨                 |
| 0x0400   | `IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP` | 스왑 파일에서 실행 (이동식 미디어)        |
| 0x0800   | `IMAGE_FILE_NET_RUN_FROM_SWAP`       | 스왑 파일에서 실행 (네트워크 드라이브)      |
| 0x1000   | `IMAGE_FILE_SYSTEM`                  | 시스템 파일                      |
| 0x2000   | `IMAGE_FILE_DLL`                     | DLL                         |
| 0x4000   | `IMAGE_FILE_UP_SYSTEM_ONLY`          | 멀티프로세서 사용자 모드(UP) 시스템 전용    |
| 0x8000   | `IMAGE_FILE_BYTES_REVERSED_HI`       | 고(高) 바이트 순서가 뒤바뀜(사용 안 함)    |



```c
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

typedef struct _IMAGE_OPTIONAL_HEADER {
    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;
    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

```

_IMAGE_OPTIONAL_HEADER에서 주요 값들은 아래의 10개이다.
- Magic : 해당 파일이 32비트(PE32)인지 64비트(PE32+)인지를 나타내는 값
- AddressOfEntryPoint : 프로그램이 시작되는 코드의 가상 주소(RVA)
- ImageBase : 로드될 때 기본적으로 매핑되는 메모리 상의 시작 주소
- SectionAlignment : 메모리에 로드할 때 각 섹션의 정렬 단위(바이트)
- FileAlignment : 디스크상에 저장될 때 각 섹션의 정렬 단위(바이트)
- SizeOfImage : 메모리에 로드된 전체 이미지(헤더 + 모든 섹션 포함)의 크기 (바이트)
- SizeOfHeader : DOS 헤더, PE 헤더 및 모든 섹션 헤더를 합친 크기 (바이트)
- Subsystem : 이 실행 파일이 어떤 환경에서 동작할지를 지정
- NumberOfRvaAndSizes : 데이터 디렉터리(Data Directory)의 엔트리 개수
- DataDirectory : 배열의 각 항목마다 정의된 값을 가지게 되는데 그 값은 아래와 같다.

| 인덱스 | 디렉터리 이름                   | 설명                                                            |
| --: | ------------------------- | ------------------------------------------------------------- |
|   0 | EXPORT\_TABLE             | 이 모듈이 외부에 제공(export)하는 함수·데이터의 목록 및 주소 테이블                    |
|   1 | IMPORT\_TABLE             | 모듈이 참조(import)하는 외부 DLL의 함수·데이터 목록 및 주소 테이블                   |
|   2 | RESOURCE\_TABLE           | 리소스 섹션(.rsrc)의 시작 주소와 크기 (아이콘, 문자열 테이블, 대화상자 리소스 등)           |
|   3 | EXCEPTION\_TABLE          | 예외 처리 루틴과 언와인드 정보(64-bit의 경우 사용됨)                             |
|   4 | CERTIFICATE\_TABLE        | 디지털 서명(Certificate Table)의 시작 주소와 크기                          |
|   5 | BASE\_RELOCATION\_TABLE   | 재배치(relocation) 정보(.reloc 섹션)의 시작 주소와 크기                      |
|   6 | DEBUG                     | 디버그 정보(심볼, 매핑 정보 등)의 시작 주소와 크기                                |
|   7 | ARCHITECTURE              | 예약(과거 IA-64용으로 사용되었으나 현재 무의미)                                 |
|   8 | GLOBAL\_PTR               | 전역 포인터(global pointer) 테이블 주소 (MIPS 등 특정 아키텍처용)               |
|   9 | TLS\_TABLE                | Thread-Local Storage 초기화 및 콜백 정보                              |
|  10 | LOAD\_CONFIG\_TABLE       | 보안 쿠키, 스택 검사, SEH 보호 등 로드 구성 정보                               |
|  11 | BOUND\_IMPORT             | 바인드된 임포트 목록(Import Table과 함께 사용, 로딩 시 바인딩 최적화)                |
|  12 | IAT                       | 실제 Import Address Table(Import Table과 유사하지만, 실행 시 패치된 주소를 담음) |
|  13 | DELAY\_IMPORT\_DESCRIPTOR | 지연 로딩(Delay-Load) DLL의 목록 및 로딩 시점 정보                          |
|  14 | CLR\_RUNTIME\_HEADER      | .NET 어셈블리용 CLR 헤더(.NET 런타임 메타데이터 시작 주소와 크기)                   |
|  15 | RESERVED                  | 예약(향후 확장 또는 특별 용도로 사용될 수 있음)                                  |

#### d. Section header
각 섹션의 속성을 정의하기 위한 헤더이다.
기본적인 섹션 헤더의 구조는 아래와 같다.

```c
#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

- VirtualSize      : 메모리에서 섹션이 차지하는 크기
- VirtualAddress   : 메모리에서 섹션의 시작 주소 (RVA)
- SizeOfRawData    : 파일에서 섹션이 차지하는 크기
- PointerToRawData : 파일에서 섹션의 시작 위치
- Characteristics  : 섹션의 특징 (bit OR), 아래의 표를 참조하면 된다.

| 값 (16진수)   | 플래그 이름                             | 설명                        |
| ---------- | ---------------------------------- | ------------------------- |
| 0x00000008 | `IMAGE_SCN_TYPE_NO_PAD`            | 섹션 패딩 없음                  |
| 0x00000020 | `IMAGE_SCN_CNT_CODE`               | 실행 코드(.text) 섹션           |
| 0x00000040 | `IMAGE_SCN_CNT_INITIALIZED_DATA`   | 초기화된 데이터(.rdata/.data) 섹션 |
| 0x00000080 | `IMAGE_SCN_CNT_UNINITIALIZED_DATA` | 초기화 안 된 데이터(.bss) 섹션      |
| 0x00000100 | `IMAGE_SCN_LNK_OTHER`              | 기타 링커 제어                  |
| 0x00000200 | `IMAGE_SCN_LNK_INFO`               | 디버그／설명용 정보                |
| 0x00000800 | `IMAGE_SCN_LNK_REMOVE`             | 링커가 제거할 섹션                |
| 0x00001000 | `IMAGE_SCN_LNK_COMDAT`             | COMDAT(overloadable) 섹션   |
| 0x00008000 | `IMAGE_SCN_GPREL`                  | 전역 포인터 상대 주소 사용           |
| 0x00020000 | `IMAGE_SCN_MEM_PURGEABLE`          | 퓨저블(purgeable)            |
| 0x00040000 | `IMAGE_SCN_MEM_LOCKED`             | 메모리 잠김                    |
| 0x00080000 | `IMAGE_SCN_MEM_PRELOAD`            | 미리 로드                     |
| 0x00100000 | `IMAGE_SCN_ALIGN_1BYTES`           | 1바이트 정렬                   |
| 0x00200000 | `IMAGE_SCN_ALIGN_2BYTES`           | 2바이트 정렬                   |
| 0x00300000 | `IMAGE_SCN_ALIGN_4BYTES`           | 4바이트 정렬                   |
| 0x00400000 | `IMAGE_SCN_ALIGN_8BYTES`           | 8바이트 정렬                   |
| 0x00500000 | `IMAGE_SCN_ALIGN_16BYTES`          | 16바이트 정렬                  |
| 0x00600000 | `IMAGE_SCN_ALIGN_32BYTES`          | 32바이트 정렬                  |
| 0x00700000 | `IMAGE_SCN_ALIGN_64BYTES`          | 64바이트 정렬                  |
| 0x00800000 | `IMAGE_SCN_ALIGN_128BYTES`         | 128바이트 정렬                 |
| 0x00900000 | `IMAGE_SCN_ALIGN_256BYTES`         | 256바이트 정렬                 |
| 0x00A00000 | `IMAGE_SCN_ALIGN_512BYTES`         | 512바이트 정렬                 |
| 0x00B00000 | `IMAGE_SCN_ALIGN_1024BYTES`        | 1 024바이트 정렬               |
| 0x00C00000 | `IMAGE_SCN_ALIGN_2048BYTES`        | 2 048바이트 정렬               |
| 0x00D00000 | `IMAGE_SCN_ALIGN_4096BYTES`        | 4 096바이트 정렬               |
| 0x00E00000 | `IMAGE_SCN_ALIGN_8192BYTES`        | 8 192바이트 정렬               |
| 0x01000000 | `IMAGE_SCN_LNK_NRELOC_OVFL`        | 재배치 수 초과(OVFL)            |
| 0x02000000 | `IMAGE_SCN_MEM_DISCARDABLE`        | 디스크로부터 제거 가능(discardable) |
| 0x04000000 | `IMAGE_SCN_MEM_NOT_CACHED`         | 캐시 불가                     |
| 0x08000000 | `IMAGE_SCN_MEM_NOT_PAGED`          | 페이징 불가                    |
| 0x10000000 | `IMAGE_SCN_MEM_SHARED`             | 공유 메모리                    |
| 0x20000000 | `IMAGE_SCN_MEM_EXECUTE`            | 실행 가능                     |
| 0x40000000 | `IMAGE_SCN_MEM_READ`               | 읽기 가능                     |
| 0x80000000 | `IMAGE_SCN_MEM_WRITE`              | 쓰기 가능                     |


### 2) PE Body
#### a. Section
> ※ 추가 업데이트 예정
{: .prompt-tip }

## 3. ELF (리눅스)
> ※ 추가 업데이트 예정
{: .prompt-tip }

# 참고자료
- [Wikipedia - Portable Executable](https://en.wikipedia.org/wiki/Portable_Executable)
- [리버스코어 - PE FILE FORMAT](https://reversecore.com/18)
- Microsoft - winnt.h
