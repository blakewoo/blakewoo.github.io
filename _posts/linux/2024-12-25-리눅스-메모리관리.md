---
title: 리눅스 - 메모리 관리
author: blakewoo
date: 2024-12-25 20:40:00 +0900
categories: [Linux]
tags: [Computer science, Linux, OS] 
render_with_liquid: false
use_math: true
---

# 메모리 관리
## 1. 페이지
커널은 물리적 페이지를 메모리 관리의 기본 단위로 사용한다.   
메모리 관리 장치(MMU)는 페이지 단위로 처리한다. 이는 사용자 레벨에서만이 아니라 커널 역시 동일하기 때문에
MMU는 페이지 크기의 정밀도를 가진 시스템 페이지 테이블을 관리한다. 

페이지 크기는 아키텍쳐별로 다르다. 하지만 대부분 32bit 아키텍쳐의 페이지 크기는 4KB이며
64bit 아키텍처의 페이지 크기는 8KB이다.
커널에서는 이러한 물리적 페이지를 표현하기 위해 struct page 구조체를 사용한다.
이 구조체는 "include/linux/mm_types.h"에 명시되어있다.

struct page 구조체를 시스템 전체의 물리적 페이지를 표현하며 이 구조체를 이용하여 모든 페이지를 관리한다.
시스템의 물리 메모리가 4GB고 물리 페이지 크기를 8KB라고 할 때 전체 구조체의 크기는 20MB이다.
전체 비율을 생각해보면 그렇게 큰 건 아닌셈이다.

### 1) 구역
하드웨어적인 문제로 인해 커널은 모든 페이지를 동일하게 취급할 수 없다.   
이는 아래와 같은 하드웨어 문제 때문이다.

- 일부 하드웨어 장치는 특정 실제 메모리 주소로만 DMA를 수행 할 수 있다.
- 일부 아키텍처에서는 가상적으로 접근 할 수 있는 것보다 더 많은 양의 메모리를 물리적으로 접근할 수 있다.
  따라서 일부 메모리는 커널 주소 공간에 상주할 수 없다.

위 두 가지 문제로 인해 총 네 가지의 주요 메모리 구역을 두고 있다.

- ZONE_DMA : DMA를 수행 할 수 있는 페이지가 있다.
- ZONE_DMA32 : DMA를 수행 할 수 있지만 32bit 장치만 접근 할 수 있다.
- ZONE_NORMAL : 통상적으로 할당 되는 페이지가 있다.
- ZONE_HIGHMEN : 커널 주소 공간에 상주하지 않는 페이지인 상위 메모리가 있다.

아키텍쳐마다 위의 구역의 사용방식과 배치는 다를 수 있다.
실제 X86-32 아키텍쳐의 경우 아래와 같이 구역과 영역이 정해져있다.

<table>
<tr>
<td>구역</td><td>설명</td><td>물리적 메모리 주소</td>
</tr>
<tr>
<td>ZONE_DMA</td><td>DMA 가능한 페이지</td><td><16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td><td>일반적으로 접근 가능한 페이지</td><td>16~896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEN</td><td>동적으로 연결되는 페이지</td><td>>896MB</td>
</tr>
</table>

X86-32 에는 ZONE_HIGHMEM 구역이 없듯이 모든 아키텍처가 모든 구역을 정의하진 않는다.
위에 구역을 나눠놓은 이유대로 DMA가 필요하면 ZONE_DMA에서, 
일반적인 경우 어지간하면 커널은 ZONE_NORMAL에서 페이지를 할당하려고 한다.
물론 메모리가 부족해지면 커널은 ZONE_DMA고 뭐고 다 갖다가 쓴다.

### 2) 페이지 가져오기
커널은 메모리 획득을 위한 저수준 방법 하나와 할당 받은 메모리에 접근하는 몇가지 인터페이스를 제공한다.
이 방법은 "include/linux/gfp.h"에 정의되어있다.

<table>
<tr>
<td>이름</td><td>설명</td>
</tr>
<tr>
<td>alloc_page(gfp_mask)</td><td>페이지 하나를 할당하고, 할당된 page 구조체 포인터를 반환한다.</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td><td>2 개수의 페이지를 페이지를 할당하고, 할당된 첫번째 페이지의 page 구조체 포인터를 반환</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td><td>페이지 하나를 할당하고, 할당된 페이지의 논리적 주소 포인터를 반환한다.</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td><td>2 개수의 페이지를 할당하고, 할당된 첫 번째 페이지의 논리적 주소 포인터를 반환한다.</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td><td>페이지 하나를 할당하고, 페이지 내용을 0으로 초기화 한 다음, 페이지의 논리적 주소 포인터를 반환한다.</td>
</table>


### 3) 페이지 반환

할당하는 함수가 있듯이 반환하는 함수 역시 있다.  
이 함수를 사용하는데는 깊은 주의가 필요한데, 주소나 order 값을 잘못 지정하면 메모리가 깨질 수 있다.
```c
void __free_pages(struct page *page, unsigned int order)
void free_pages(unsigned long addr, unsigned int order)
void free_page(unsigned long addr)
```

※ 추가 포스팅 예정

# 참고문헌
- 리눅스 커널 심층분석 (에이콘 임베디드 시스템프로그래밍 시리즈 33,  로버트 러브 저자(글) · 황정동 번역)
- [리눅스 커널 6.7 버전](https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.6.7.tar.gz)
