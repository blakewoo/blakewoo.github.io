---
title: 리눅스 - 프로세스 스케줄링
author: blakewoo
date: 2024-12-11 19:30:00 +0900
categories: [Linux]
tags: [Computer science, Linux, OS] 
render_with_liquid: false
use_math: true
---

# 프로세스 스케줄링
## 1. 개요
대부분의 운영체제가 그러하듯 리눅스 역시 시분할 처리를 통해 멀티태스킹을 구현한다.    
시분할 처리란 cpu 동작시간이란 유한한 자원을 특정 시간만큼 쪼개어 각 프로세스에 할당하는 것이다.    
이 cpu를 어떤 프로세스에 얼마나 오랫동안 할당 할 것인지 결정하는 방법론이 필요한데 이러한 것을 프로세스 스케줄링이라 한다.
이전에 스케줄링에 대한 간략한 개요에 대해서 포스팅한 적이 있으니 [이곳](https://blakewoo.github.io/posts/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9-2/) 을 참고하면 좋다
이전 포스팅에서 정의한 내용은 별도로 정의하지 않을 것이니 미리 넘어가서 보고 오는게 읽는데 편할 것이다.

이번 포스팅에서는 리눅스에서 어떤 방식을 통해 스케줄링을 하는지 알아보도록 하겠다.

## 2. 리눅스의 프로세스 스케줄러의 변천사

### a. 첫버전 ~ 2.4
가장 첫버전부터 2.4 커널까지 리눅스 스케줄러는 간단하고 평범하게 설계되었다. 때문에 프로세스가 많거나 프로세서가 많은 시스템에서는 확장성있게 구동되지 않았다.

### b. 2.5 : O(1) 스케줄러
2.5 커널 시리즈부터 스케줄러 정비 작업에 들어갔는데, 이때 만들어진 새로운 스케줄러는 O(1) 스케줄러라고 불렸다.    
시간복잡도를 나타내는 Big O 표기법에서 따온 이 스케줄렁 이름은 입력 크기와 상관없이 일정한 시간안에 작업을 수행한다는 뜻인데, 타임 슬라이스 계산 과정에서
상수 시간 알고리즘을 저용했고, 프로세서마다 별도의 실행 대기열을 만들어 이전 스케줄러에 있었던 확장성 떨어지는 제약을 제거했다.   
수십개의 프로세서를 가진 커다란 시스템을 리눅스가 지원할 수 있게 되고 O(1) 스케줄러는 사용할만한 성능을 보여주었으나 응답시간에 민감한 애플리케이션에 대해서는
큰 문제가 발견되었다. 대화형 어플리케이션이 주된 데스크톱 시스템에서는 써먹지 못할 정도로 느렸던 것이다.

### c. 2.6 ~ 최신
대화형 성능을 개선하기 위해 새로운 스케줄러가 도입되었다. 회단 계단식 기한 스케줄러(Rotating Staircase Deadline Scheduler)로 공정 스케줄링 개념을 
큐잉 이론에서 가져다 적용했다. 여기서 발전하여 2.6.23버전부터 CFS(Completely Fair Scheduler)라고 불리는 완전 공정 스케줄러가 O(1) 스케줄러를 대신하게 되었다.

## 3. CFS(Completely Fair Scheduler) 개념
## 4. 코드 분석
※ 추가 포스팅 예정

# 참고문헌
- 리눅스 커널 심층분석 (에이콘 임베디드 시스템프로그래밍 시리즈 33,  로버트 러브 저자(글) · 황정동 번역)
