---
title: 리눅스 - 가상 파일 시스템
author: blakewoo
date: 2024-12-29 20:40:00 +0900
categories: [Linux]
tags: [Computer science, Linux, OS] 
render_with_liquid: false
use_math: true
---

# 가상 파일 시스템(Virtual Filesystem)

## 1. 개요
가상 파일 시스템(Virtual Filesystem, 혹은 Virtual File Switch 라고도 한다)인 VFS는 파일시스템 관련 인터페이스를 사용자 공간
애플리케이션에 제공하고 파일을 구현하는 커널 서브 시스템이다. 모든 파일시스템은 VFS를 통해 공존이 가능할 뿐만 아니라 상호 동작도 가능하다.
요컨대 ext3 파일 시스템을 쓰는 하드 디스크와 ext2 파일 시스템을 사용하는 이동식 디스크라도 VFS를 통해 서로간에 데이터를 옮길 수 있다는 뜻이다.

VFS는 open(), write(), read() 같은 시스템 호출이 파일 시스템이나 물리적 매체의 종류와 상관없이 동작하게 해주는 역할을 한다.
이는 가상 인터페이스를 통해 파일 시스템에 접근하기 때문에 가능한 것으로 과거에는 이런 일이 불가했다.
어떻게 가능하게 되었을까?

이는 리눅스에서 커널이 하위 파일 시스템 인터페이스에 대한 추상화 계층을 제공하기 때문에 가능한 것이다.
리눅스에서 제공하는 기능과 동작이 다른 여러 파일 시스템을 이 추상화 계층을 통해 지원한다.
그렇기 때문에 다른 포맷으로 이루어진 파일 시스템에서 서로간의 데이터를 전달 할 수 있는 것이다.
이 모델은 파일 시스템 하부의 자세한 동작을 이해할 필요가 없게 만들어주었다.

![img.png](/assets/blog/linux/vfs/img.png)

하지만 우리는 VFS의 세세한 구조를 알아야하므로 좀 더 세부적으로 알아보겠다.

## 2. 유닉스 파일 시스템
기본적으로 VFS는 유닉스 스타일 파일 시스템에 편향된 디자인을 하고 있다. 따라서 우리가 VFS에 대해서 알아보기 위해서는
유닉스 파일 시스템 스타일을 알아야 한다.
역사적으로 유닉스에는 아래의 네 가지 추상화 개념이 있었다.

### 1) 마운트(mount)
유닉스에서 파일 시스템은 이름공간이라는 전역 계층 구조의 특정 지점에 부착(mount)된다. 이렇게 해서 모든 파일 시스템이 하나의
노드에 나무 가지와 같은 형태로 붙어있다.

### 2) 파일
바이트가 정렬된 문자열이다. 

### 3) 디렉토리
관련 파일을 모아두는 폴더에 비유 할 수 있음 하위 디렉토리라는 다른 디렉토리가 디렉토리에 들어갈 수 있으므로
중첩하여 경로를 구성할 수 있다.

### 4) 아이노드(inode)
접근 권한, 크기, 소유자, 생성 시간 같은 파일 관련 정보들은 파일 개념과 분리되어있으며 이런 정보들을 파일 메타데이터라고 한다.
이 정보는 파일과 별도로 존재하는 자료 구조에 저장하는데 이를 아이노드라고 한다.  index node의 줄임말이다.

## 3. VFS 객체와 자료구조
리눅스 커널은 객체지향 언어가 아닌 C로 짜여있지만 객체 지향 프로그래밍을 사용하는 부분이 많다.   
특히 VFS의 경우 객체 관점으로 생각하는 것이 좋다.
자료구조는 C 구조체로 짜여있으며 이 구조체에는 데이터와 데이터를 조작하는 파일 시스템 구현 함수 포인터가 들어 있다.

VFS 객체는 아래와 같이 네 가지 유형이 있다.

### 1) 슈퍼 블록 객체
마운트된 파일 시스템을 표현하는 객체이다. 각 파일 시스템 별로 구현하며 파일 시스템을 기술하는 정보를 저장한다.
이 객체는 보통 디스크의 특별한 섹터에 저장하는 파일 시스템 슈퍼 블록 또는 파일 시스템 제어 블록에 대응된다.
(이 부분은 EXT 계열 파일시스템 포스팅을 하면서 추가적으로 나올 것이다)
디스크 기반이 아닌 파일 시스템의 경우에는 슈퍼블록을 실시간으로 생성해 메모리에 저장한다.

슈퍼블록 객체는 "include/linux/fs.h" 파일에 정의된 super_block 구조체를 이용하여 표현되어있다.
이 구조체를 조작하기 위한 함수 역시 있는데 이는 동일한 파일에 super_operations 구조체로 표현된다.

> ※ 추가 포스팅 예정
{: .prompt-tip }

### 2) 아이노드 객체
파일을 표현하는 객체이다. 위에서 언급했듯이 메타데이터를 표현하는 객체이며, 커널이 파일이나 디렉토리를 관리하는데 필요한 모든
정보를 담고 있따. 유닉스 스타일의 시스템에서는 간단히 디스크상의 아이노드를 읽기만하면 되지만 그런 시스템이 아니라면 어딘가 저장되어있는
데이터를 읽어들여야하는데 아이노드가 없는 시스템이라면 파일과 함께 저장하는 경우가 일반적이다.

이러한 아이노드 객체는 "include/linux/fs.h"에 정의된 struct node 구조체를 사용하여 표현한다.
아이노드는 파일시스템의 각 파일을 나타낸다. 하지만 아이노드 객체는 파일에 접근할 때 메모리에서만 생성된다.
이 객체 역시 함수가 있다. 이 함수는 동일한 파일에 inode_operations 라는 구조체에 정의되어있다.

> ※ 추가 포스팅 예정
{: .prompt-tip }

### 3) 덴트리 객체
경로를 구성하는 요소인 디렉토리 항목을 표현하는 객체이다. 이는 VFS가 디렉토리를 파일의 일종으로 간주하기 때문에
이런 별도의 객체가 필요하다. 실질적으로 "/bin/node"라는 경로가 있을때 bin과 node 둘다 파일이다.
물론 여기서 bin은 디렉토리 파일이고 node는 보통 파일이 될 것이다.
아이노드 객체로 각각의 구성요소를 나타낼 수는 있겠으나 경로명 탐색과 같은 디렉토리 전용 작업을 수행해야하는 경우가 많다.
때문에 이런 기능을 구현하기 위해 디렉토리 항목(덴트리)라는 개념을 도입했으며 이는 경로상의 항목을 말한다.

이 덴트리 객체는 "include/linux/dcache.h" 파일에 정의된 struct dentry 구조체를 사용해 표현한다.
이 구조체에 대한 함수는 동일한 파일에 dentry_operation 구조체에 정의되어있다.

> ※ 추가 포스팅 예정
{: .prompt-tip }

### 4) 파일 객체
프로세스가 사용하는 열린 파일을 표현하는 객체이다. 파일 객체는 열린 파일을 메모리 상에서 나타낸 것으로 이 객체는
open() 시스템 호출에 의해 메모리에 만들어지고 close() 시스템 호출로 메모리에서 사라진다.
한 파일을 여러 프로세스에서 사용할 수 있기 때문에 한 개의 파일에 대해 다수의 파일 객체가 있을 수 있다.

파일 객체는 "include/linux/fs.h"에 정의된 struct file 구조체로 표현한다.
여기서 file 구조체는 디스크 상의 실제 데이터가 포함되어있지 ㅇ낳다.
파일 객체에 대한 함수도 역시 동일한 파일에 file_opertaions 구조체로 표현된다.

> ※ 추가 포스팅 예정
{: .prompt-tip }



# 참고문헌
- 리눅스 커널 심층분석 (에이콘 임베디드 시스템프로그래밍 시리즈 33,  로버트 러브 저자(글) · 황정동 번역)
- [리눅스 커널 6.6.7 버전](https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.6.7.tar.gz)
