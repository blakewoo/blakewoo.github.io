---
title: 리눅스 - 가상 파일 시스템
author: blakewoo
date: 2024-12-29 20:40:00 +0900
categories: [Linux]
tags: [Computer science, Linux, OS] 
render_with_liquid: false
use_math: true
---

# 가상 파일 시스템(Virtual Filesystem)

> ※ 아직 해당 포스팅 작성이 완료되지 않았으므로 참고만 하기 바람
{: .prompt-tip }

## 1. 개요
가상 파일 시스템(Virtual Filesystem, 혹은 Virtual File Switch 라고도 한다)인 VFS는 파일시스템 관련 인터페이스를 사용자 공간
애플리케이션에 제공하고 파일을 구현하는 커널 서브 시스템이다. 모든 파일시스템은 VFS를 통해 공존이 가능할 뿐만 아니라 상호 동작도 가능하다.
요컨대 ext3 파일 시스템을 쓰는 하드 디스크와 ext2 파일 시스템을 사용하는 이동식 디스크라도 VFS를 통해 서로간에 데이터를 옮길 수 있다는 뜻이다.

VFS는 open(), write(), read() 같은 시스템 호출이 파일 시스템이나 물리적 매체의 종류와 상관없이 동작하게 해주는 역할을 한다.
이는 가상 인터페이스를 통해 파일 시스템에 접근하기 때문에 가능한 것으로 과거에는 이런 일이 불가했다.
어떻게 가능하게 되었을까?

이는 리눅스에서 커널이 하위 파일 시스템 인터페이스에 대한 추상화 계층을 제공하기 때문에 가능한 것이다.
리눅스에서 제공하는 기능과 동작이 다른 여러 파일 시스템을 이 추상화 계층을 통해 지원한다.
그렇기 때문에 다른 포맷으로 이루어진 파일 시스템에서 서로간의 데이터를 전달 할 수 있는 것이다.
이 모델은 파일 시스템 하부의 자세한 동작을 이해할 필요가 없게 만들어주었다.

![img.png](/assets/blog/linux/vfs/img.png)

하지만 우리는 VFS의 세세한 구조를 알아야하므로 좀 더 세부적으로 알아보겠다.

## 2. 유닉스 파일 시스템
기본적으로 VFS는 유닉스 스타일 파일 시스템에 편향된 디자인을 하고 있다. 따라서 우리가 VFS에 대해서 알아보기 위해서는
유닉스 파일 시스템 스타일을 알아야 한다.
역사적으로 유닉스에는 아래의 네 가지 추상화 개념이 있었다.

### 1) 마운트(mount)
유닉스에서 파일 시스템은 이름공간이라는 전역 계층 구조의 특정 지점에 부착(mount)된다. 이렇게 해서 모든 파일 시스템이 하나의
노드에 나무 가지와 같은 형태로 붙어있다.

### 2) 파일
바이트가 정렬된 문자열이다. 

### 3) 디렉토리
관련 파일을 모아두는 폴더에 비유 할 수 있음 하위 디렉토리라는 다른 디렉토리가 디렉토리에 들어갈 수 있으므로
중첩하여 경로를 구성할 수 있다.

### 4) 아이노드(inode)
접근 권한, 크기, 소유자, 생성 시간 같은 파일 관련 정보들은 파일 개념과 분리되어있으며 이런 정보들을 파일 메타데이터라고 한다.
이 정보는 파일과 별도로 존재하는 자료 구조에 저장하는데 이를 아이노드라고 한다. index node의 줄임말이다.

## 3. VFS 객체와 자료구조
리눅스 커널은 객체지향 언어가 아닌 C로 짜여있지만 객체 지향 프로그래밍을 사용하는 부분이 많다.   
특히 VFS의 경우 객체 관점으로 생각하는 것이 좋다.
자료구조는 C 구조체로 짜여있으며 이 구조체에는 데이터와 데이터를 조작하는 파일 시스템 구현 함수 포인터가 들어 있다.

VFS 객체는 아래와 같이 네 가지 유형이 있다.

### 1) 슈퍼 블록 객체
마운트된 파일 시스템을 표현하는 객체이다. 각 파일 시스템 별로 구현하며 파일 시스템을 기술하는 정보를 저장한다.
이 객체는 보통 디스크의 특별한 섹터에 저장하는 파일 시스템 슈퍼 블록 또는 파일 시스템 제어 블록에 대응된다.
([파일 시스템 2 - EXT](https://blakewoo.github.io/posts/EXT/) 포스팅을 참고하면 좋다) 디스크 기반이 아닌 파일 시스템의 경우에는 슈퍼블록을 실시간으로 생성해 메모리에 저장한다.

슈퍼블록 객체는 "include/linux/fs.h" 파일에 정의된 super_block 구조체를 이용하여 표현되어있다.
아는 몇가지 부분은 한글로 주석을 달아두었다.
```c
struct super_block {
	struct list_head	s_list;		/* Keep this first */ // 모든 슈퍼블록 리스트
	dev_t			s_dev;		/* search index; _not_ kdev_t */  // 식별자
	unsigned char		s_blocksize_bits;  // 비트 단위의 블록 크기
	unsigned long		s_blocksize; // 바이트 단위의 블록 크기
	loff_t			s_maxbytes;	/* Max file size */ 
	struct file_system_type	*s_type; // 파일 시스템 유형
	const struct super_operations	*s_op; // 슈퍼 블록 함수
	const struct dquot_operations	*dq_op; // 사용량 제한 함수
	const struct quotactl_ops	*s_qcop; // 사용량 제어 함수
	const struct export_operations *s_export_op; // 파일 시스템 외부 제공 함수
	unsigned long		s_flags; // 마운트 플래그
	unsigned long		s_iflags;	/* internal SB_I_* flags */
	unsigned long		s_magic; // 파일 시스템 고유 번호
	struct dentry		*s_root; // 디렉토리 마운트 지점
	struct rw_semaphore	s_umount; // 마운트 해제용 세마포어
	int			s_count;  // 슈퍼 블록 참조 횟수
	atomic_t		s_active;  // 활성화 상태 참조 횟수
#ifdef CONFIG_SECURITY 
	void                    *s_security; // 보안 모듈
#endif
	const struct xattr_handler * const *s_xattr; // 확장 속성 핸들러
#ifdef CONFIG_FS_ENCRYPTION 
	const struct fscrypt_operations	*s_cop;
	struct fscrypt_keyring	*s_master_keys; /* master crypto keys in use */
#endif
#ifdef CONFIG_FS_VERITY
	const struct fsverity_operations *s_vop;
#endif
#if IS_ENABLED(CONFIG_UNICODE)
	struct unicode_map *s_encoding;
	__u16 s_encoding_flags;
#endif
	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
	struct block_device	*s_bdev; // 관련 블록 디바이스ㄴ
	struct bdev_handle	*s_bdev_handle;
	struct backing_dev_info *s_bdi;
	struct mtd_info		*s_mtd; // 메모리 디스크 정보
	struct hlist_node	s_instances; // 같은 파일시스템 인스턴스
	unsigned int		s_quota_types;	/* Bitmask of supported quota types */
	struct quota_info	s_dquot;	/* Diskquota specific options */ // 사용량 제한 관련 옵션

	struct sb_writers	s_writers; 

	/*
	 * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and
	 * s_fsnotify_marks together for cache efficiency. They are frequently
	 * accessed and rarely modified.
	 */
	void			*s_fs_info;	/* Filesystem private info */

	/* Granularity of c/m/atime in ns (cannot be worse than a second) */
	u32			s_time_gran;
	/* Time limits for c/m/atime in seconds */
	time64_t		   s_time_min;
	time64_t		   s_time_max;
#ifdef CONFIG_FSNOTIFY
	__u32			s_fsnotify_mask;
	struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;
#endif

	char			s_id[32];	/* Informational name */ // 이름 문자열
	uuid_t			s_uuid;		/* UUID */ 

	unsigned int		s_max_links;

	/*
	 * The next field is for VFS *only*. No filesystems have any business
	 * even looking at it. You had been warned.
	 */
	struct mutex s_vfs_rename_mutex;	/* Kludge */

	/*
	 * Filesystem subtype.  If non-empty the filesystem type field
	 * in /proc/mounts will be "type.subtype"
	 */
	const char *s_subtype; // 하부 유형 이름

	const struct dentry_operations *s_d_op; /* default d_op for dentries */

	struct shrinker *s_shrink;	/* per-sb shrinker handle */

	/* Number of inodes with nlink == 0 but still referenced */
	atomic_long_t s_remove_count;

	/*
	 * Number of inode/mount/sb objects that are being watched, note that
	 * inodes objects are currently double-accounted.
	 */
	atomic_long_t s_fsnotify_connectors;

	/* Read-only state of the superblock is being changed */
	int s_readonly_remount;

	/* per-sb errseq_t for reporting writeback errors via syncfs */
	errseq_t s_wb_err;

	/* AIO completions deferred from interrupt context */
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;

	/*
	 * Owning user namespace and default context in which to
	 * interpret filesystem uids, gids, quotas, device nodes,
	 * xattrs and security labels.
	 */
	struct user_namespace *s_user_ns;

	/*
	 * The list_lru structure is essentially just a pointer to a table
	 * of per-node lru lists, each of which has its own spinlock.
	 * There is no need to put them into separate cachelines.
	 */
	struct list_lru		s_dentry_lru; // 미사용 디렉토리 항목 리스트
	struct list_lru		s_inode_lru; 
	struct rcu_head		rcu;
	struct work_struct	destroy_work;

	struct mutex		s_sync_lock;	/* sync serialisation lock */

	/*
	 * Indicates how deep in a filesystem stack this SB is
	 */
	int s_stack_depth;

	/* s_inode_list_lock protects s_inodes */
	spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
	struct list_head	s_inodes;	/* all inodes */

	spinlock_t		s_inode_wblist_lock;
	struct list_head	s_inodes_wb;	/* writeback inodes */
} __randomize_layout;

```

이 구조체를 조작하기 위한 함수 역시 있는데 이는 동일한 파일에 super_operations 구조체로 표현된다.

```c
struct super_operations {
  struct inode *(*alloc_inode)(struct super_block *sb); 
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *); 

  void (*dirty_inode) (struct inode *, int flags); 
	int (*write_inode) (struct inode *, struct writeback_control *wbc); 
	int (*drop_inode) (struct inode *); 
	void (*evict_inode) (struct inode *); 
	void (*put_super) (struct super_block *); 
	int (*sync_fs)(struct super_block *sb, int wait); 
	int (*freeze_super) (struct super_block *, enum freeze_holder who);
	int (*freeze_fs) (struct super_block *);
	int (*thaw_super) (struct super_block *, enum freeze_holder who);
	int (*unfreeze_fs) (struct super_block *);
	int (*statfs) (struct dentry *, struct kstatfs *); 
	int (*remount_fs) (struct super_block *, int *, char *); 
	void (*umount_begin) (struct super_block *); 

	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
#ifdef CONFIG_QUOTA
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot **(*get_dquots)(struct inode *);
#endif
	long (*nr_cached_objects)(struct super_block *,
				  struct shrink_control *);
	long (*free_cached_objects)(struct super_block *,
				    struct shrink_control *);
	void (*shutdown)(struct super_block *sb);
};
```

#### ※ 함수 설명

``alloc_inode``
this method is called by alloc_inode() to allocate memory for
struct inode and initialize it.  If this function is not
defined, a simple 'struct inode' is allocated.  Normally
alloc_inode will be used to allocate a larger structure which
contains a 'struct inode' embedded within it.

``destroy_inode``
this method is called by destroy_inode() to release resources
allocated for struct inode.  It is only required if
->alloc_inode was defined and simply undoes anything done by
->alloc_inode.

``free_inode``
this method is called from RCU callback. If you use call_rcu()
in ->destroy_inode to free 'struct inode' memory, then it's
better to release memory in this method.

``dirty_inode``
this method is called by the VFS when an inode is marked dirty.
This is specifically for the inode itself being marked dirty,
not its data.  If the update needs to be persisted by fdatasync(),
then I_DIRTY_DATASYNC will be set in the flags argument.
I_DIRTY_TIME will be set in the flags in case lazytime is enabled
and struct inode has times updated since the last ->dirty_inode
call.

``write_inode``
this method is called when the VFS needs to write an inode to
disc.  The second parameter indicates whether the write should
be synchronous or not, not all filesystems check this flag.

``drop_inode``
called when the last access to the inode is dropped, with the
inode->i_lock spinlock held.

	This method should be either NULL (normal UNIX filesystem
	semantics) or "generic_delete_inode" (for filesystems that do
	not want to cache inodes - causing "delete_inode" to always be
	called regardless of the value of i_nlink)

	The "generic_delete_inode()" behavior is equivalent to the old
	practice of using "force_delete" in the put_inode() case, but
	does not have the races that the "force_delete()" approach had.

``evict_inode``
called when the VFS wants to evict an inode. Caller does
*not* evict the pagecache or inode-associated metadata buffers;
the method has to use truncate_inode_pages_final() to get rid
of those. Caller makes sure async writeback cannot be running for
the inode while (or after) ->evict_inode() is called. Optional.

``put_super``
called when the VFS wishes to free the superblock
(i.e. unmount).  This is called with the superblock lock held

``sync_fs``
called when VFS is writing out all dirty data associated with a
superblock.  The second parameter indicates whether the method
should wait until the write out has been completed.  Optional.

``freeze_super``
Called instead of ->freeze_fs callback if provided.
Main difference is that ->freeze_super is called without taking
down_write(&sb->s_umount). If filesystem implements it and wants
->freeze_fs to be called too, then it has to call ->freeze_fs
explicitly from this callback. Optional.

``freeze_fs``
called when VFS is locking a filesystem and forcing it into a
consistent state.  This method is currently used by the Logical
Volume Manager (LVM) and ioctl(FIFREEZE). Optional.

``thaw_super``
called when VFS is unlocking a filesystem and making it writable
again after ->freeze_super. Optional.

``unfreeze_fs``
called when VFS is unlocking a filesystem and making it writable
again after ->freeze_fs. Optional.

``statfs``
called when the VFS needs to get filesystem statistics.

``remount_fs``
called when the filesystem is remounted.  This is called with
the kernel lock held

``umount_begin``
called when the VFS is unmounting a filesystem.

``show_options``
called by the VFS to show mount options for /proc/<pid>/mounts
and /proc/<pid>/mountinfo.
(see "Mount Options" section)

``show_devname``
Optional. Called by the VFS to show device name for
/proc/<pid>/{mounts,mountinfo,mountstats}. If not provided then
'(struct mount).mnt_devname' will be used.

``show_path``
Optional. Called by the VFS (for /proc/<pid>/mountinfo) to show
the mount root dentry path relative to the filesystem root.

``show_stats``
Optional. Called by the VFS (for /proc/<pid>/mountstats) to show
filesystem-specific mount statistics.

``quota_read``
called by the VFS to read from filesystem quota file.

``quota_write``
called by the VFS to write to filesystem quota file.

``get_dquots``
called by quota to get 'struct dquot' array for a particular inode.
Optional.

``nr_cached_objects``
called by the sb cache shrinking function for the filesystem to
return the number of freeable cached objects it contains.
Optional.

``free_cache_objects``
called by the sb cache shrinking function for the filesystem to
scan the number of objects indicated to try to free them.
Optional, but any filesystem implementing this method needs to
also implement ->nr_cached_objects for it to be called
correctly.

	We can't do anything with any errors that the filesystem might
	encountered, hence the void return type.  This will never be
	called if the VM is trying to reclaim under GFP_NOFS conditions,
	hence this method does not need to handle that situation itself.

	Implementations must include conditional reschedule calls inside
	any scanning loop that is done.  This allows the VFS to
	determine appropriate scan batch sizes without having to worry
	about whether implementations will cause holdoff problems due to
	large scan batch sizes.


### 2) 아이노드 객체
파일을 표현하는 객체이다. 위에서 언급했듯이 메타데이터를 표현하는 객체이며, 커널이 파일이나 디렉토리를 관리하는데 필요한 모든
정보를 담고 있따. 유닉스 스타일의 시스템에서는 간단히 디스크상의 아이노드를 읽기만하면 되지만 그런 시스템이 아니라면 어딘가 저장되어있는
데이터를 읽어들여야하는데 아이노드가 없는 시스템이라면 파일과 함께 저장하는 경우가 일반적이다.

이러한 아이노드 객체는 "include/linux/fs.h"에 정의된 struct inode 구조체를 사용하여 표현한다.

```c
struct inode {
	umode_t			i_mode; // 접근 권한
	unsigned short		i_opflags;
	kuid_t			i_uid; // 소유자 사용자 id
	kgid_t			i_gid; // 소유자 그룹 id
	unsigned int		i_flags; // 파일시스템 플래그

#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl;
#endif

	const struct inode_operations	*i_op; // 아이노드 동작 테이블
	struct super_block	*i_sb; // 아이노드가 속한 슈퍼블록
	struct address_space	*i_mapping; // 아이노드 관련 연결 정보

#ifdef CONFIG_SECURITY
	void			*i_security; // 보안 모듈
#endif

	/* Stat data, not accessed from path walking */
	unsigned long		i_ino; // 아이노드 번호
	/*
	 * Filesystems may only read i_nlink directly.  They shall use the
	 * following functions for modification:
	 *
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 */
	union {
		const unsigned int i_nlink; // 하드링크 개수
		unsigned int __i_nlink; 
	};
	dev_t			i_rdev;  // 실제 디바이스 노드
	loff_t			i_size;  // 바이트 단위 파일 크기
	struct timespec64	__i_atime;  // 마지막 접근 시간
	struct timespec64	__i_mtime;  // 마지막 수정시간
	struct timespec64	__i_ctime; /* use inode_*_ctime accessors! */ // 마지막 변경 시간
	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */ // 스핀락
	unsigned short          i_bytes;  // 사용한 바이트
	u8			i_blkbits;  // 비트 단위 블록 크기
	u8			i_write_hint; 
	blkcnt_t		i_blocks;  // 블록 단위 파일 크기
 
#ifdef __NEED_I_SIZE_ORDERED
	seqcount_t		i_size_seqcount;  // i_size 변수 직렬화를 위한 카운터
#endif

	/* Misc */
	unsigned long		i_state; // 상태 플래그
	struct rw_semaphore	i_rwsem;

	unsigned long		dirtied_when;	/* jiffies of first dirtying */ // 최초변경 시간
	unsigned long		dirtied_time_when;

	struct hlist_node	i_hash;  // 해시 리스트
	struct list_head	i_io_list;	/* backing dev IO list */
#ifdef CONFIG_CGROUP_WRITEBACK
	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */

	/* foreign inode detection, see wbc_detach_inode() */
	int			i_wb_frn_winner;
	u16			i_wb_frn_avg_time;
	u16			i_wb_frn_history;
#endif
	struct list_head	i_lru;		/* inode LRU list */
	struct list_head	i_sb_list;   // 슈퍼블록 리스트
	struct list_head	i_wb_list;	/* backing dev writeback list */
	union {
		struct hlist_head	i_dentry;  // 디렉토리 항목 리스트
		struct rcu_head		i_rcu;
	};
	atomic64_t		i_version; 
	atomic64_t		i_sequence; /* see futex */
	atomic_t		i_count;  // 참조 횟수
	atomic_t		i_dio_count;
	atomic_t		i_writecount;
#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)
	atomic_t		i_readcount; /* struct files open RO */
#endif
	union {
		const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */ // 기본 아이노드 동작
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context	*i_flctx;
	struct address_space	i_data;
	struct list_head	i_devices; // 블록 장치 리스트
	union {
		struct pipe_inode_info	*i_pipe; // 파이프 정보
		struct cdev		*i_cdev; // 캐릭터 장치 드라이버
		char			*i_link;
		unsigned		i_dir_seq;
	};

	__u32			i_generation;

#ifdef CONFIG_FSNOTIFY
	__u32			i_fsnotify_mask; /* all events this inode cares about */
	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
#endif

#ifdef CONFIG_FS_ENCRYPTION
	struct fscrypt_inode_info	*i_crypt_info;
#endif

#ifdef CONFIG_FS_VERITY
	struct fsverity_info	*i_verity_info;
#endif

	void			*i_private; /* fs or device private pointer */ // vkdlf tltmxpa soqndyd vhdlsxj
} __randomize_layout;
```


아이노드는 파일시스템의 각 파일을 나타낸다. 하지만 아이노드 객체는 파일에 접근할 때 메모리에서만 생성된다.
이 객체 역시 함수가 있다. 이 함수는 동일한 파일에 inode_operations 라는 구조체에 정의되어있다.

```c
struct inode_operations {
	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
	const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); 
	int (*permission) (struct mnt_idmap *, struct inode *, int); 
	struct posix_acl * (*get_inode_acl)(struct inode *, int, bool); // 

	int (*readlink) (struct dentry *, char __user *,int); 

	int (*create) (struct mnt_idmap *, struct inode *,struct dentry *,
		       umode_t, bool); 
	int (*link) (struct dentry *,struct inode *,struct dentry *); 
	int (*unlink) (struct inode *,struct dentry *); 
	int (*symlink) (struct mnt_idmap *, struct inode *,struct dentry *,
			const char *); // 지정된 이름으로 심볼릭 링크를 생성한다.
	int (*mkdir) (struct mnt_idmap *, struct inode *,struct dentry *,
		      umode_t); // 새로운 디렉터리를 생성한다.
	int (*rmdir) (struct inode *,struct dentry *); 
	int (*mknod) (struct mnt_idmap *, struct inode *,struct dentry *,
		      umode_t,dev_t); 
	int (*rename) (struct mnt_idmap *, struct inode *, struct dentry *,
			struct inode *, struct dentry *, unsigned int); 
	int (*setattr) (struct mnt_idmap *, struct dentry *, struct iattr *); 
	int (*getattr) (struct mnt_idmap *, const struct path *, 
			struct kstat *, u32, unsigned int); 
	ssize_t (*listxattr) (struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
		      u64 len);
	int (*update_time)(struct inode *, int);
	int (*atomic_open)(struct inode *, struct dentry *,
			   struct file *, unsigned open_flag,
			   umode_t create_mode);
	int (*tmpfile) (struct mnt_idmap *, struct inode *,
			struct file *, umode_t);
	struct posix_acl *(*get_acl)(struct mnt_idmap *, struct dentry *,
				     int);
	int (*set_acl)(struct mnt_idmap *, struct dentry *,
		       struct posix_acl *, int);
	int (*fileattr_set)(struct mnt_idmap *idmap,
			    struct dentry *dentry, struct fileattr *fa);
	int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);
	struct offset_ctx *(*get_offset_ctx)(struct inode *inode);
} ____cacheline_aligned;
```

#### ※ 함수 설명

``create``
called by the open(2) and creat(2) system calls.  Only required
if you want to support regular files.  The dentry you get should
not have an inode (i.e. it should be a negative dentry).  Here
you will probably call d_instantiate() with the dentry and the
newly created inode

``lookup``
called when the VFS needs to look up an inode in a parent
directory.  The name to look for is found in the dentry.  This
method must call d_add() to insert the found inode into the
dentry.  The "i_count" field in the inode structure should be
incremented.  If the named inode does not exist a NULL inode
should be inserted into the dentry (this is called a negative
dentry).  Returning an error code from this routine must only be
done on a real error, otherwise creating inodes with system
calls like create(2), mknod(2), mkdir(2) and so on will fail.
If you wish to overload the dentry methods then you should
initialise the "d_dop" field in the dentry; this is a pointer to
a struct "dentry_operations".  This method is called with the
directory inode semaphore held

``link``
called by the link(2) system call.  Only required if you want to
support hard links.  You will probably need to call
d_instantiate() just as you would in the create() method

``unlink``
called by the unlink(2) system call.  Only required if you want
to support deleting inodes

``symlink``
called by the symlink(2) system call.  Only required if you want
to support symlinks.  You will probably need to call
d_instantiate() just as you would in the create() method

``mkdir``
called by the mkdir(2) system call.  Only required if you want
to support creating subdirectories.  You will probably need to
call d_instantiate() just as you would in the create() method

``rmdir``
called by the rmdir(2) system call.  Only required if you want
to support deleting subdirectories

``mknod``
called by the mknod(2) system call to create a device (char,
block) inode or a named pipe (FIFO) or socket.  Only required if
you want to support creating these types of inodes.  You will
probably need to call d_instantiate() just as you would in the
create() method

``rename``
called by the rename(2) system call to rename the object to have
the parent and name given by the second inode and dentry.

	The filesystem must return -EINVAL for any unsupported or
	unknown flags.  Currently the following flags are implemented:
	(1) RENAME_NOREPLACE: this flag indicates that if the target of
	the rename exists the rename should fail with -EEXIST instead of
	replacing the target.  The VFS already checks for existence, so
	for local filesystems the RENAME_NOREPLACE implementation is
	equivalent to plain rename.
	(2) RENAME_EXCHANGE: exchange source and target.  Both must
	exist; this is checked by the VFS.  Unlike plain rename, source
	and target may be of different type.

``get_link``
called by the VFS to follow a symbolic link to the inode it
points to.  Only required if you want to support symbolic links.
This method returns the symlink body to traverse (and possibly
resets the current position with nd_jump_link()).  If the body
won't go away until the inode is gone, nothing else is needed;
if it needs to be otherwise pinned, arrange for its release by
having get_link(..., ..., done) do set_delayed_call(done,
destructor, argument).  In that case destructor(argument) will
be called once VFS is done with the body you've returned.  May
be called in RCU mode; that is indicated by NULL dentry
argument.  If request can't be handled without leaving RCU mode,
have it return ERR_PTR(-ECHILD).

	If the filesystem stores the symlink target in ->i_link, the
	VFS may use it directly without calling ->get_link(); however,
	->get_link() must still be provided.  ->i_link must not be
	freed until after an RCU grace period.  Writing to ->i_link
	post-iget() time requires a 'release' memory barrier.

``readlink``
this is now just an override for use by readlink(2) for the
cases when ->get_link uses nd_jump_link() or object is not in
fact a symlink.  Normally filesystems should only implement
->get_link for symlinks and readlink(2) will automatically use
that.

``permission``
called by the VFS to check for access rights on a POSIX-like
filesystem.

	May be called in rcu-walk mode (mask & MAY_NOT_BLOCK).  If in
	rcu-walk mode, the filesystem must check the permission without
	blocking or storing to the inode.

	If a situation is encountered that rcu-walk cannot handle,
	return
	-ECHILD and it will be called again in ref-walk mode.

``setattr``
called by the VFS to set attributes for a file.  This method is
called by chmod(2) and related system calls.

``getattr``
called by the VFS to get attributes of a file.  This method is
called by stat(2) and related system calls.

``listxattr``
called by the VFS to list all extended attributes for a given
file.  This method is called by the listxattr(2) system call.

``update_time``
called by the VFS to update a specific time or the i_version of
an inode.  If this is not defined the VFS will update the inode
itself and call mark_inode_dirty_sync.

``atomic_open``
called on the last component of an open.  Using this optional
method the filesystem can look up, possibly create and open the
file in one atomic operation.  If it wants to leave actual
opening to the caller (e.g. if the file turned out to be a
symlink, device, or just something filesystem won't do atomic
open for), it may signal this by returning finish_no_open(file,
dentry).  This method is only called if the last component is
negative or needs lookup.  Cached positive dentries are still
handled by f_op->open().  If the file was created, FMODE_CREATED
flag should be set in file->f_mode.  In case of O_EXCL the
method must only succeed if the file didn't exist and hence
FMODE_CREATED shall always be set on success.

``tmpfile``
called in the end of O_TMPFILE open().  Optional, equivalent to
atomically creating, opening and unlinking a file in given
directory.  On success needs to return with the file already
open; this can be done by calling finish_open_simple() right at
the end.

``fileattr_get``
called on ioctl(FS_IOC_GETFLAGS) and ioctl(FS_IOC_FSGETXATTR) to
retrieve miscellaneous file flags and attributes.  Also called
before the relevant SET operation to check what is being changed
(in this case with i_rwsem locked exclusive).  If unset, then
fall back to f_op->ioctl().

``fileattr_set``
called on ioctl(FS_IOC_SETFLAGS) and ioctl(FS_IOC_FSSETXATTR) to
change miscellaneous file flags and attributes.  Callers hold
i_rwsem exclusive.  If unset, then fall back to f_op->ioctl().
``get_offset_ctx``
called to get the offset context for a directory inode. A
filesystem must define this operation to use
simple_offset_dir_operations.


### 3) 덴트리 객체
경로를 구성하는 요소인 디렉토리 항목을 표현하는 객체이다. 이는 VFS가 디렉토리를 파일의 일종으로 간주하기 때문에
이런 별도의 객체가 필요하다. 실질적으로 "/bin/node"라는 경로가 있을때 bin과 node 둘다 파일이다.
물론 여기서 bin은 디렉토리 파일이고 node는 보통 파일이 될 것이다.
아이노드 객체로 각각의 구성요소를 나타낼 수는 있겠으나 경로명 탐색과 같은 디렉토리 전용 작업을 수행해야하는 경우가 많다.
때문에 이런 기능을 구현하기 위해 디렉토리 항목(덴트리)라는 개념을 도입했으며 이는 경로상의 항목을 말한다.

이 덴트리 객체는 "include/linux/dcache.h" 파일에 정의된 struct dentry 구조체를 사용해 표현한다.

```c
struct dentry {
	/* RCU lookup touched fields */
	unsigned int d_flags;		/* protected by d_lock */
	seqcount_spinlock_t d_seq;	/* per dentry seqlock */
	struct hlist_bl_node d_hash;	/* lookup hash list */
	struct dentry *d_parent;	/* parent directory */
	struct qstr d_name;
	struct inode *d_inode;		/* Where the name belongs to - NULL is
					 * negative */
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */

	/* Ref lookup also touches following */
	struct lockref d_lockref;	/* per-dentry lock and refcount */
	const struct dentry_operations *d_op;
	struct super_block *d_sb;	/* The root of the dentry tree */
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */

	union {
		struct list_head d_lru;		/* LRU list */
		wait_queue_head_t *d_wait;	/* in-lookup ones only */
	};
	struct list_head d_child;	/* child of parent list */
	struct list_head d_subdirs;	/* our children */
	/*
	 * d_alias and d_rcu can share memory
	 */
	union {
		struct hlist_node d_alias;	/* inode alias list */
		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
	 	struct rcu_head d_rcu;
	} d_u;
} __randomize_layout;
```

이 구조체에 대한 함수는 동일한 파일에 dentry_operation 구조체에 정의되어있다.

```c
struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int); 
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *,
			unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char *(*d_dname)(struct dentry *, char *, int);
	struct vfsmount *(*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry *(*d_real)(struct dentry *, const struct inode *);
} ____cacheline_aligned;
```

#### ※ 함수 설명

``d_revalidate``
called when the VFS needs to revalidate a dentry.  This is
called whenever a name look-up finds a dentry in the dcache.
Most local filesystems leave this as NULL, because all their
dentries in the dcache are valid.  Network filesystems are
different since things can change on the server without the
client necessarily being aware of it.

	This function should return a positive value if the dentry is
	still valid, and zero or a negative error code if it isn't.

	d_revalidate may be called in rcu-walk mode (flags &
	LOOKUP_RCU).  If in rcu-walk mode, the filesystem must
	revalidate the dentry without blocking or storing to the dentry,
	d_parent and d_inode should not be used without care (because
	they can change and, in d_inode case, even become NULL under
	us).

	If a situation is encountered that rcu-walk cannot handle,
	return
	-ECHILD and it will be called again in ref-walk mode.

``d_weak_revalidate``
called when the VFS needs to revalidate a "jumped" dentry.  This
is called when a path-walk ends at dentry that was not acquired
by doing a lookup in the parent directory.  This includes "/",
"." and "..", as well as procfs-style symlinks and mountpoint
traversal.

	In this case, we are less concerned with whether the dentry is
	still fully correct, but rather that the inode is still valid.
	As with d_revalidate, most local filesystems will set this to
	NULL since their dcache entries are always valid.

	This function has the same return code semantics as
	d_revalidate.

	d_weak_revalidate is only called after leaving rcu-walk mode.

``d_hash``
called when the VFS adds a dentry to the hash table.  The first
dentry passed to d_hash is the parent directory that the name is
to be hashed into.

	Same locking and synchronisation rules as d_compare regarding
	what is safe to dereference etc.

``d_compare``
called to compare a dentry name with a given name.  The first
dentry is the parent of the dentry to be compared, the second is
the child dentry.  len and name string are properties of the
dentry to be compared.  qstr is the name to compare it with.

	Must be constant and idempotent, and should not take locks if
	possible, and should not or store into the dentry.  Should not
	dereference pointers outside the dentry without lots of care
	(eg.  d_parent, d_inode, d_name should not be used).

	However, our vfsmount is pinned, and RCU held, so the dentries
	and inodes won't disappear, neither will our sb or filesystem
	module.  ->d_sb may be used.

	It is a tricky calling convention because it needs to be called
	under "rcu-walk", ie. without any locks or references on things.

``d_delete``
called when the last reference to a dentry is dropped and the
dcache is deciding whether or not to cache it.  Return 1 to
delete immediately, or 0 to cache the dentry.  Default is NULL
which means to always cache a reachable dentry.  d_delete must
be constant and idempotent.

``d_init``
called when a dentry is allocated

``d_release``
called when a dentry is really deallocated

``d_iput``
called when a dentry loses its inode (just prior to its being
deallocated).  The default when this is NULL is that the VFS
calls iput().  If you define this method, you must call iput()
yourself

``d_dname``
called when the pathname of a dentry should be generated.
Useful for some pseudo filesystems (sockfs, pipefs, ...) to
delay pathname generation.  (Instead of doing it when dentry is
created, it's done only when the path is needed.).  Real
filesystems probably dont want to use it, because their dentries
are present in global dcache hash, so their hash should be an
invariant.  As no lock is held, d_dname() should not try to
modify the dentry itself, unless appropriate SMP safety is used.
CAUTION : d_path() logic is quite tricky.  The correct way to
return for example "Hello" is to put it at the end of the
buffer, and returns a pointer to the first char.
dynamic_dname() helper function is provided to take care of
this.

	Example :

.. code-block:: c

	static char *pipefs_dname(struct dentry *dent, char *buffer, int buflen)
	{
		return dynamic_dname(dentry, buffer, buflen, "pipe:[%lu]",
				dentry->d_inode->i_ino);
	}

``d_automount``
called when an automount dentry is to be traversed (optional).
This should create a new VFS mount record and return the record
to the caller.  The caller is supplied with a path parameter
giving the automount directory to describe the automount target
and the parent VFS mount record to provide inheritable mount
parameters.  NULL should be returned if someone else managed to
make the automount first.  If the vfsmount creation failed, then
an error code should be returned.  If -EISDIR is returned, then
the directory will be treated as an ordinary directory and
returned to pathwalk to continue walking.

	If a vfsmount is returned, the caller will attempt to mount it
	on the mountpoint and will remove the vfsmount from its
	expiration list in the case of failure.  The vfsmount should be
	returned with 2 refs on it to prevent automatic expiration - the
	caller will clean up the additional ref.

	This function is only used if DCACHE_NEED_AUTOMOUNT is set on
	the dentry.  This is set by __d_instantiate() if S_AUTOMOUNT is
	set on the inode being added.

``d_manage``
called to allow the filesystem to manage the transition from a
dentry (optional).  This allows autofs, for example, to hold up
clients waiting to explore behind a 'mountpoint' while letting
the daemon go past and construct the subtree there.  0 should be
returned to let the calling process continue.  -EISDIR can be
returned to tell pathwalk to use this directory as an ordinary
directory and to ignore anything mounted on it and not to check
the automount flag.  Any other error code will abort pathwalk
completely.

	If the 'rcu_walk' parameter is true, then the caller is doing a
	pathwalk in RCU-walk mode.  Sleeping is not permitted in this
	mode, and the caller can be asked to leave it and call again by
	returning -ECHILD.  -EISDIR may also be returned to tell
	pathwalk to ignore d_automount or any mounts.

	This function is only used if DCACHE_MANAGE_TRANSIT is set on
	the dentry being transited from.

``d_real``
overlay/union type filesystems implement this method to return
one of the underlying dentries hidden by the overlay.  It is
used in two different modes:

	Called from file_dentry() it returns the real dentry matching
	the inode argument.  The real dentry may be from a lower layer
	already copied up, but still referenced from the file.  This
	mode is selected with a non-NULL inode argument.

	With NULL inode the topmost real underlying dentry is returned.

### 4) 파일 객체
프로세스가 사용하는 열린 파일을 표현하는 객체이다. 파일 객체는 열린 파일을 메모리 상에서 나타낸 것으로 이 객체는
open() 시스템 호출에 의해 메모리에 만들어지고 close() 시스템 호출로 메모리에서 사라진다.
한 파일을 여러 프로세스에서 사용할 수 있기 때문에 한 개의 파일에 대해 다수의 파일 객체가 있을 수 있다.

파일 객체는 "include/linux/fs.h"에 정의된 struct file 구조체로 표현한다.
여기서 file 구조체는 디스크 상의 실제 데이터가 포함되어있지 않다.

```c
struct file {
	union {
		struct llist_node	f_llist;
		struct rcu_head 	f_rcuhead;
		unsigned int 		f_iocb_flags;
	};

	/*
	 * Protects f_ep, f_flags.
	 * Must not be taken from IRQ context.
	 */
	spinlock_t		f_lock;
	fmode_t			f_mode;
	atomic_long_t		f_count;
	struct mutex		f_pos_lock;
	loff_t			f_pos;
	unsigned int		f_flags;
	struct fown_struct	f_owner;
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
	const struct file_operations	*f_op;

	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	/* needed for tty driver, and maybe others */
	void			*private_data;

#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct hlist_head	*f_ep;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
	errseq_t		f_wb_err;
	errseq_t		f_sb_err; /* for syncfs */
} __randomize_layout
  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
```

파일 객체에 대한 함수도 역시 동일한 파일에 file_opertaions 구조체로 표현된다.

```c
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,
			unsigned int flags);
	int (*iterate_shared) (struct file *, struct dir_context *);
	__poll_t (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	unsigned long mmap_supported_flags;
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct file *file);
	int (*setlease)(struct file *, int, struct file_lock **, void **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);
#endif
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
			loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
				   struct file *file_out, loff_t pos_out,
				   loff_t len, unsigned int remap_flags);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,
				unsigned int poll_flags);
} __randomize_layout;
```

#### ※ 함수 설명

``llseek``
called when the VFS needs to move the file position index

``read``
called by read(2) and related system calls

``read_iter``
possibly asynchronous read with iov_iter as destination

``write``
called by write(2) and related system calls

``write_iter``
possibly asynchronous write with iov_iter as source

``iopoll``
called when aio wants to poll for completions on HIPRI iocbs

``iterate_shared``
called when the VFS needs to read the directory contents

``poll``
called by the VFS when a process wants to check if there is
activity on this file and (optionally) go to sleep until there
is activity.  Called by the select(2) and poll(2) system calls

``unlocked_ioctl``
called by the ioctl(2) system call.

``compat_ioctl``
called by the ioctl(2) system call when 32 bit system calls are
used on 64 bit kernels.

``mmap``
called by the mmap(2) system call

``open``
called by the VFS when an inode should be opened.  When the VFS
opens a file, it creates a new "struct file".  It then calls the
open method for the newly allocated file structure.  You might
think that the open method really belongs in "struct
inode_operations", and you may be right.  I think it's done the
way it is because it makes filesystems simpler to implement.
The open() method is a good place to initialize the
"private_data" member in the file structure if you want to point
to a device structure

``flush``
called by the close(2) system call to flush a file

``release``
called when the last reference to an open file is closed

``fsync``
called by the fsync(2) system call.  Also see the section above
entitled "Handling errors during writeback".

``fasync``
called by the fcntl(2) system call when asynchronous
(non-blocking) mode is enabled for a file

``lock``
called by the fcntl(2) system call for F_GETLK, F_SETLK, and
F_SETLKW commands

``get_unmapped_area``
called by the mmap(2) system call

``check_flags``
called by the fcntl(2) system call for F_SETFL command

``flock``
called by the flock(2) system call

``splice_write``
called by the VFS to splice data from a pipe to a file.  This
method is used by the splice(2) system call

``splice_read``
called by the VFS to splice data from file to a pipe.  This
method is used by the splice(2) system call

``setlease``
called by the VFS to set or release a file lock lease.  setlease
implementations should call generic_setlease to record or remove
the lease in the inode after setting it.

``fallocate``
called by the VFS to preallocate blocks or punch a hole.

``copy_file_range``
called by the copy_file_range(2) system call.

``remap_file_range``
called by the ioctl(2) system call for FICLONERANGE and FICLONE
and FIDEDUPERANGE commands to remap file ranges.  An
implementation should remap len bytes at pos_in of the source
file into the dest file at pos_out.  Implementations must handle
callers passing in len == 0; this means "remap to the end of the
source file".  The return value should the number of bytes
remapped, or the usual negative error code if errors occurred
before any bytes were remapped.  The remap_flags parameter
accepts REMAP_FILE_* flags.  If REMAP_FILE_DEDUP is set then the
implementation must only remap if the requested file ranges have
identical contents.  If REMAP_FILE_CAN_SHORTEN is set, the caller is
ok with the implementation shortening the request length to
satisfy alignment or EOF requirements (or any other reason).

``fadvise``
possibly called by the fadvise64() system call.


# 참고문헌
- 리눅스 커널 심층분석 (에이콘 임베디드 시스템프로그래밍 시리즈 33,  로버트 러브 저자(글) · 황정동 번역)
- [리눅스 커널 6.6.7 버전](https://www.kernel.org/pub/linux/kernel/v6.x/linux-6.6.7.tar.gz)
- 리눅스 커널 소스내 공식 도큐먼트 (Documentation/filesystems/vfs.rst)
