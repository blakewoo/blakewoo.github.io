---
title: Blockchain - bitcoin
author: blakewoo
date: 2025-9-23 20:30:00 +0900
categories: [Blockchain]
tags: [Blockchain, Bitcoin] 
render_with_liquid: false
use_math: true
---

# Bitcoin
## 1. 개요
이전 blockchain의 개요 포스팅에서 언급했듯이 2008년 세계 금융 위기로 인해 생겨난 개개인간의 전자 결제 시스템이다.   
사토시 나카모토(높은 확률로 가명이다)라는 사람이 백서(Bitcone : A Peer-to-peer Electronic Cash System)를 발표함에 따라 시작되었으며   
blockchain 기술의 모태가 되었다. 사이퍼펑크(사이버 펑크가 아니다) 즉, 사회적, 정치적 변화의 방법으로 강력한 암호 기술과 프라이버시 강화
기술의 광범위한 사용을 옹호하는 이들의 사상에서 시작되었다고 봐도 무방할 듯 하다.

소위 말해서 이러한 blockchain 기술은 탈 중앙화가 가장 주요한 내용이다. 중앙화가 되어있다는 것은 내가 어떤 작업이나 결제를 했을 때 요청할 곳이
정해져있다는 뜻이다. 하지만 탈 중앙화라면 그런 요청할 곳이 정해지지 않았다는 뜻인데, 그렇다면 어떻게 결제와 작업에 대해서 보증하고 보관할 수 있을까?   
이를 컴퓨터 공학적인 관점에서 알아보겠다.

## 2. 주요 개념
### 1) SHA256
암호학을 배웠다면 이름은 들어봤을 함수이다.미국 국가 안보국(NAS) 설계한 암호이며, 어떤 값을 넣으면 그에 따른 고정된 크기의 무작위값이 나타나는 함수이다.   
약간의 값이라도 달라진다면 결과값 역시 완전 달라지기 때문에 어떤 데이터가 변조되었는지 확인하기에 용이하여 데이터 무결성을 판단하는데 사용한다.

### 2) 공개키 암호화
비대칭 암호 방식이라고도 불리며 전자서명시 많이 사용한다. 비밀키와 공개키로 이루어져있으며 비밀키로 암호화시 공개키로 복호화가능하고
공개키로 암호화시 비밀키로 복호화 가능하다.

## 3. 전체적인 구조
### 1) bitcoin core
이 bitcoin에 대해서 이해하기 위해서는 먼저 bitcoin core라는 것을 알아야한다.   
내가 이 bitcoin에 대해서 가장 의문스러웠던게 바로 이 탈중앙화 부분이었다.
결제를 하건 송금을 하건 요청을 할 텐데, 이 요청을 받는곳은 대체 어디인가 하는 것이다.
이때 이 요청을 받는 주체가 바로 bitcoin core(이하 코어)이다.   

이러한 코어는 bitcoin 공식 사이트에서 배포한다. 설치하면 누구든 운영가능하며 요청 수용의 주체이다. 물론 bitcoin 커뮤니티에서 자체적으로
운용하는 코어도 많다. dns이름으로 제공되며, 해당 dns로 접근시 항상 켜져있는 무작위 코어의 주소를 받는다.
커뮤니티에서 운용중인 코어들은 후원을 받아서 운용되며 처음 코어를 설치하고 운용할때 진입점이 된다.

그렇다면 커뮤니티에서 운용하는 코어가 모종의 이유로 shutdown 된다면 비트코인은 운용할 수 없는걸까? 그건 아니다. 일단 코어가 가동되면   
가장 가까운 대략 8개의 코어와 연결된다. 해당 코어에서 어떤 결제가 일어나면 관련 내용이 이 8개에 전파되고 내용을 전파받은 8개는 다른 코어에
다시 전파하는 식인 것이다.(토폴로지 적으로는 mesh network에 가깝다)
때문에 만약에 커뮤니티에서 운용되는 코어가 shutdown되더라도 한번 접속한 다른 코어의 주소를 기억하고 있기 때문에
운용간에는 문제가 없으며, 전파된 결제 내역은 코어에 코어를 통해 전파되어 전체 네트워크로 전파된다.

### 2) 거래와 채굴
Transaction이라고 불리는 거래는 다음과 같다. A와 B가 있다고 할때 A가 B에게 3 BTC를 송금하고 싶다고 하자.   
그러면 A는 이전 거래 블록의 해시값과 거래 내역, B의 공개키 해시를 포함해서 A의 비밀키로 암호화하여 연결된 코어에게 전파한다.
이렇게 비밀키로 암호화하는 것을 전자서명이라고 하며 A의 공개키로 이를 복호화하여 확인가능하다.

이렇게 이루어진 거래에 대한 내역은 내역을 수취한 코어에서 미확정 거래풀에 보관된다. 이후 이 거래에 대해서 확정(confirmation)을 거치게 된다.
이 과정에서 사용되는 것이 SHA256이라는 함수이다. 이 SHA256이라는 것은 해시 함수이다. 어떤 입력값을 받았을 때 일정한 길이의 무작위처리된
값을 출력하는 함수이다. 거래에 대해서 확정 받기 위해서는 네트워크가 정한 값에 대해서 아래의 연산 결과가 해당 값보다 작거나 같아야한다.

- 거래들의 해시 + 이전 블록 해시 + 난스(임의의 값)

해시 함수는 입력값이 같으면 같은 값을 출력하지만 각 입력 값과 출력 값 사이의 연관점을 찾을 수 없기 때문에 brute force를 통해 모두 체크해봐야한다.   
(이 과정은 의존성이 없기 때문에 병렬화 시키기에 매우 요긴한데, 이 때문에 GPU가 채굴하는 과정에서 많이 사용된 것이다)
만약 해당 조건을 만족하는 난스 값을 찾는다면 거래들의 해시와 이전 블록의 해시와 난스 값을 포함하여 해시해서 연결된 코어에 즉, 네트워크에 브로드 캐스팅해서
확정을 받는다. 이 과정에서 새로운 block을 체인에 달게 되는 것이다.   
이 과정에서 Incentive로 얼마간의 bitcoin(새로운 bitcoin + 거래 수수료)를 받게되는데 이를 채굴이라고 한다. 

#### ※ 거래 수수료
갑자기 거래 수수료는 왜 튀어나오는거지 싶을 수 있다. 먼저 채굴을 위해서는 미확정 거래풀에서 거래들을 모으는 과정이 필요한데
이 과정에서 미확정 거래를 수집하는 기준이 수수료이다. 수수료가 큰 거래를 처리할 수록 채굴 간에 얻는 Bitcoin이 많기 때문에
수수료가 높은 거래일 수록 더 빨리 확정된다.

### 3) UTXO(Unspent Transaction Output)
bitcoin은 코어들의 상호작용으로 인해 신뢰성이 유지된다. 그렇다면 비트코인의 거래와 잔고는 어떻게 유지되는 걸까?   
답은 간단하다. 각 거래원장에 사용되지 않은 bitcoin 잔량을 포함하는 형태로 기재하는 것이다.    
가령 A와 B가 있다고 할때 아래와 같이 송금했다고 하자 (A가 이미 100 BTC를 갖고 있다고 가정)

- A가 B에게 20BTC를 송금

그러면 A는 80 BTC가 있고 B가 BTC가 있음을 명시하는 것이다.   
정확하게 말하자면 A가 사용한 BTC가 B로 이동되는 것이 아닌 사용한 만큼 A의 계정에서 BTC는 소멸되고 B에 송금한 만큼
B의 계정에서 BTC가 생성되는 걸로 보면 된다.

좀 살펴보면 DB에서 멱등성 있는 형태의 로그를 남기는 것과 비슷해 보인다.

### 4) Orphan chain(Stale chain)
기본적으로 Bitcoin 네트워크는 내 결함성이 강하고 가용성이 높지만 Mesh 구조이기 때문에 Network가 split될수 있다.   
그럴 경우 각 네트워크마다 확정되며 이후 네트워크가 연결될 경우 각 체인의 길이를 비교하여 짧은 체인(Orphan chain or Stale chain)이 버려지며 해당 체인에 들어있던
거래들은 다시 미확정 거래로 돌아가게 된다.

이 때문에 bitcoin의 거래를 조작하기 위해서는 전체 체인을 압도하는 양의 컴퓨팅파워가 있어야하므로 전체 코어 개수의 51%를 넘게 점유해야 가능하다.

## 4. 위협
### 1) 양자컴퓨터 도입으로 인한 암호화 무력화
거래에 대해서 서명시 공개키 방식의 전자서명을 사용하기 때문에 양자 컴퓨터의 연산에 취약한 형태이다.   
이는 공개키 방식의 전자서명은 기본적으로 큰 소수가 소인수 분해하기 힘들다는 특성을 이용해서 현재의 암호체계가 유지되고있는 것인데
양자 컴퓨터를 사용할 수 있다면 쇼어 알고리즘으로 인해 시도 횟수가 매우 줄어들기 때문이다.
때문에 양자 컴퓨터의 상용화 이전에 비트코인 커뮤니티의 개발자들이 양자 내성 암호를 사용하거나 혹은 양자 블록체인을 코어 알고리즘에 도입해야한다.
기본적으로 채굴에 사용되는 해시 함수도 양자 컴퓨터에 위험하나 이는 키의 길이나 결과의 길이를 늘이면 어느정도 대처가 되므로 당장은 문제가 없다.
다만 이 부분 역시 비트코인 알고리즘에 수정되야할 것이다.

### 2) Y2K38로 인한 Timestamp overflow
기본적으로 비트코인의 Header에는 timestamp가 포함되어있다. 이 timestamp는 이전 block의 이후의 현재 block이 생성되었다는 시간적 증명이기도한데
문제는 이 timestamp는 4Bytes의 크기를 갖고 있다. 이는 컴퓨터공학에서 말하는 int형 정수 타입의 최대 크기와 같은데
기본적으로 1970년 1월 1일 자정 UTC를 기준으로 몇초나 지났는지 표기하는 것이다.   
하지만 2038년 1월 19일 03:14:07 UTC이면 4Bytes가 1로 꽉차서 Overflow 현상이 일어난다.   
때문에 이 부분 역시 비트코인에서 4bytes를 8bytes로 늘리든 다른 방식을 사용하든 방법을 강구해야한다.

> ※ 추가 업데이트 및 검증 예정이다.
{: .prompt-tip }

# 참고문헌
- Satoshi Nakamoto, "Bitcone : A Peer-to-peer Electronic Cash System", bitcoin, 2008, https://bitcoin.org/bitcoin.pdf
- [비트코인 공식 사이트](https://bitcoin.org/ko/)
- [사이퍼펑크 - 위키백과](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8D%BC%ED%8E%91%ED%81%AC)
- [김승주의 암호세상 - 양자 컴퓨터로 비트코인을 깰 수 있다?](https://m.blog.naver.com/amhoin/222430804690)
- [위키백과 - SHA2](https://ko.wikipedia.org/wiki/SHA-2)
- [위키백과 - 공개 키 암호 방식](https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D)
- 비트코인이란 무엇인가, 레드스톤, 사토시 나카모토 지음, 고피디 번역 · 해설
