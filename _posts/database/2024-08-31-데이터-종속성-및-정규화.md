---
title: 데이터 종속성 및 정규화
author: blakewoo
date: 2024-9-1 21:30:00 +0900
categories: [Database]
tags: [Computer science, Database]
render_with_liquid: false
use_math: true
---

# 데이터 종속성
## 개요
데이터 베이스의 설계를 잘못하게 되면 삽입, 수정, 삭제간에 문제가 발생할 수 있다.
이렇게 발생한 문제를 이상현상이라고 하는데 이상현상의 실제적인 예시는 아래와 같다.
- 삽입 : 레코드 삽입시 부득이하게 NULL 입력
- 수정 : 데이터 일관성 훼손 - 일부 테이블에만 값이 업데이트 됨
- 삭제 : 연쇄 삭제 - 같이 저정된 다른 정보까지 같이 삭제되는 것

따라서 데이터를 적절하게 분할할 필요가 있다.
이 과정에서 함수 종속성을 판단하고 기본키를 정하여 정규화를 하게 된다.

## 함수 종속성(Functional Dependency)
테이블을 구성하는 속성 간의 의존 관계이다.

속성 B가 속성 A에 종속한다. $\to$ 속성 A값을 알면 다른 속성 B의 값이 유일하게 정해진다.   
이 경우 A $\to$ B : A는 B의 결정자이고 B는 종속 속성이라고 한다.

테이블에 존재하는 모든 종속 관계를 구하면, 이 집합으로부터 유도할 수 있는 종속관계가 있다.
이러한 규칙을 함수 종속성 규칙이라고 하며, 윌리암 암스트롱에 의해 발표되었기 때문에 암스트롱의 공리라고도 부른다.
내용은 아래와 같으며 아래의 테이블을 기준으로 예시를 들어보겠다.

![img.png](/assets/blog/database/normalization/img.png)



### 부분 집합의 규칙
집합 A가 B에 부분집합이면, B는 A이다.    
ex)    
(부서 번호, 사무실 번호) $\to$ 부서번호

### 증가 규칙
A가 B라면 AZ는 BZ이다.   
ex)   
(프로젝트 번호, 사번) $\to$ (프로젝트 이름, 사번)

### 이행 규칙
A가 B고 B가 C면 A는 C다.   
ex)   
사번 $\to$ 사무실 번호   
사번이 정해지면 부서번호가 정해지고 부서번호가 정해지면 사무실 번호가 정해지기 때문이다.

위 세 가지 규칙으로 유도할 수 있는 규칙으로는 아래의 규칙이 있다.

### 결합 규칙
A가 B고 A가 C면, A는 BC이다.   
ex)   
사번 $\to$ (이름, 거주지)

### 분해 규칙
A가 BC면 A는 B이고 A는 C이다.   
ex)
사번 $\to$ 이름, 사번 $\to$ 거주지

### 유사이행 규칙
A가 B고 DB는 C면 DA는 C이다.   
ex)   
(프로젝트 이름, 사번) $\to$ 기여도

## 분할

### 무손실 조인 분할(Lossless Join Decomposition)
간단히 말해서 하나의 테이블에서 분할된 두 개의 테이블을 다시 조인연산했을 때 데이터 손실이 없다면
그렇게 분할한 방법이 무손실 조인 분할이다.    
실제적으로 무손실 조인 분할을 하는 조건은 아래와 같다.   

R = R1 $\cup$ R2 일때   
R1 $\cap$ R2 $\to$ R1이나 R1 $\cap$ R2 $\to$ R2중 하나를 만족하여야한다.

### 종속성 보존 분할(Dependency Preservation Decomposition)
분할 되기전 함수 종속성들이 분할 후에도 유지되는 분할   
테이블 R이 $R_{1}, R_{2}, ... R_{n}$으로 분해 되었을 때
함수 종속성 집합 F도 각 테이블에 속한 속성만을 포함한 함수적 종속 집합 $F_{1}, F_{2}, ... F_{n}$으로 분해   
이때 $F' = F_{1} \cup F_{2} \cup ... \cup F_{n}$이라고 하면, 일반적으로 $F' \neq  F$
하지만 $F' \neq F$일때도 $F'^{\*} = F^{\*}$일 때 종속성 보존 분할이다.

# 정규화 (Normalization)
## 개요
데이터 중복, 삽입/삭제/갱신 이상현상이 있는 테이블을 분할하는 과정으로
정보의 손실이 없게끔, 즉 무손실 조인 분할과 종송석 보전 분할이 만족하는 분할과정이다.

## 정규형
테이블이 갖는 제약 조건에 따라 분류한 것으로 아래의 종류가 있다.

### 정규형의 종류
#### 제 1 정규형(First Normal Form: 1NF)
모든 속성들이 원자값(atomic value)만을 갖는 경우이다.   
테이블이 단순/단일 속성들로만 구성되어있는 경우이다.

정규형이 아닌 테이블에서 제 1 정규형으로 변경
![img_1.png](/assets/blog/database/normalization/img_1.png)

이런 경우 부분 종속성(Partial Dependency)가 존재한다.
부분 종속성이란 기본키가 복합키일 경우 기본키를 구성하는 속성중 일부에게 종속된 경우를 뜻한다.

#### 제 2 정규형(Second Normal Form: 2NF)
제 1 정규형이며, 주 키에 속하지 않는 모든 속성이 주키에 완전 종속인 테이블이다.
이 경우 제 1 정규형 처럼 부분 종속성 문제가 발생하지 않는다.

하지만 제 2 정규형의 경우 이행 종속성(Transitive Dependency) 문제가 존재한다.
이행 종속성이란 A,B,C 속성이 있을 경우, A->B, B->C라는 종속 관계가 있을 때
A->C가 성립될 때 이행 종속성이라고 말한다.

#### 제 3 정규형(Third Normal Form : 3NF)
제 2 정규형이면서 주키에 속하지 않는 모든 속성이 주 키에 이행적 함수 종속이 아닌 테이블이다.
이행적 함수 종속이 아니기 때문에 이행 종속성 문제는 발생하지 않는다.

하지만 주 키에 포함되지 않는 속성에서 주 키의 일부 속성으로 함수 종속성이 존재하는 경우가 생긴다.


#### 보이스-코드 정규형(Boyce-Codd Normal Form : BCNF)
모든 함수 종속성 결정자는 후보키인 상태이다.

# 반 정규화
말만 들어선 반만 정규화 하는 것인가 할 수 있겠지만
정규화의 목적 자체가 같은 데이터가 다른 테이블에 중복하여 들어가서 이상현상을 막는 것이 목적이니만큼
반 정규화는 그에 반하여 이상현상을 일으키는게 목적이라고 할 수 있다.

그렇다면 왜 일부러 이렇게 데이터 중복을 일으키는가?   
이는 조인이 발생시키는 overhead 탓이다.
조인 연산으로 인해 리소스 낭비를 하느니 차라리 데이터를 중복으로 두어 읽기 연산 성능을 올리자는게 주요 골자이다.

뿐만 아니라 아래의 경우에도 반 정규화한다.

- 다량의 범위를 자주 처리해야하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우

이렇듯 관계형 데이터 베이스의 성능에 대한 문제가 제기되자 아예 기존 관계형 데이터 베이스의 형태를
탈피한 데이터 베이스의 형태가 나타났으니 흔히들 No-SQL Database라고 하며 다음 시간에 이어서 포스팅하겠다.


# 참고자료
- [위키백과 - 데이터베이스](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)
- 대학생 시절 강의 자료
- [[데이터베이스] 정규화(이상현상, 함수종속성, 무손실 분해)](https://shout-to-my-mae.tistory.com/416)
- 데이터베이스, 이한출판사, 김경창 외 2명
- [소품집 - [SQL] 정규화(Normalization)와 반정규화(De-Normalization)](https://sodayeong.tistory.com/106)
