---
title: 공간 데이터 베이스 - 최근접 이웃 검색(R-tree)
author: blakewoo
date: 2025-10-1 23:00:00 +0900
categories: [Database]
tags: [Computer science, Database, Spacial Database, Nearest Neighbor]
render_with_liquid: false
use_math: true
---

# R-tree에서 최근접 이웃 검색
## 1. 개요
Vector DB에서 말하는 그 최근접 이웃이 맞다. 물론 공간 데이터베이스는 2차원 혹은 3차원을 주로 다루기 때문에 VectorDB의 최근접 이웃 탐색보다
더 먼저이며, ANN을 다루는 것고 달리 공간 데이터 베이스에서는 진짜로 제일 가까운 값을 반환해주어야한다.

이를 위한 방법에 대해서 이번 포스팅간에 알아보겠다.

## 2. Depth-first Search
쿼리를 Q라고 하자. 이 Q에서 가장 가까운 점 또는 객체를 찾기 위한 가장 심플한 방법이다. 
DFS라고 하지만 사실 R 트리를 하나씩 Search해서 알아보는 것과 같다. 각각의 Entry들과 Q를 비교하여 가장 가까운 것을 뽑아내는 것으로
사실상 전체 검색과 다를바 없다.

## 3. Branch and bound
95년도 sigmod에 나온 논문으로 여기서는 각 Node별로 우선순위큐가 있다. 그리고 우선 순위는 기본적으로 MINDIST에 의해 결정되며
가지치기를 위한 MINMAXDIST가 있다. 쿼리를 Q라고 하자.

### 1) MINDIST
MINDIST는 Q에서 대상 MBB에서 가장 가까운 거리를 MINDIST라고 한다. 변에 가깝다면 변에 직교하는 형태이거나, 혹은 모서리에 접하는 형태이다.
모든 MBB에 대해서 MINDIST를 구했을 때 가장 작은 MINDIST보다는 긴 거리에 최근접 이웃이 있다.

![img.png](/assets/blog/database/spacial_database/r_tree_knn/img.png)

### 2) MINMAXDIST
가장 가까운 변의 가장 먼 거리를 말한다. 그래서 가장 가까운(MIN)곳에서 먼(MAX)거리라고 MINMAXDIST이다.   
이 거리가 설명하는 것은 어떤 최근접값은 모든 MBB의 MINMAXDIST중에 가장 작은 값보다 짧은 거리내에 최근접 이웃이 있다는 뜻이다.

![img_1.png](/assets/blog/database/spacial_database/r_tree_knn/img_1.png)

### 3) Branch pruning
위와 같은 MINDIST와 MINMAXDIST를 통해 가지치기를 할 수 있다.

- 상위 노드에서 하위 노드로 탐색시 : 어떤 MBB인 R에 대해서 MINDIST가 어떤 MBB인 R'의 MINMAXDIST보다 크다면 R에 대해서 탐색하지 않아도 된다.
  
  ![img.png](/assets/blog/database/spacial_database/r_tree_knn/img_2.png)


- 상위 노드에서 하위 노드로 탐색시 : 어떤 MBB인 R에 대해서 실질 객체 O와의 거리가 R의 MINMAXDIST보다 크다면 객체 O는 탐색하지 않아도 된다.
  
  ![img_1.png](/assets/blog/database/spacial_database/r_tree_knn/img_3.png)


- 하위에서 상위노드로 다시 올라올시 : 어떤 MBB인 R에 대해서 실질 객체 O와의 거리가 R의 MINDIST 보다 작다면 R은 더 탐색하지 않아도 된다.

  ![img_2.png](/assets/blog/database/spacial_database/r_tree_knn/img_4.png)

### 4) 알고리즘
위 가지치기 규칙을 기반으로 아래와 같은 알고리즘으로 탐색을 진행한다.
위에서 미리 언급했다 시피 R 트리의 각 노드는 우선순위 큐를 가지고 있으며 이를 ABL(Active Branch List)라고 한다. 
여기서 우선순위 대상은 MINDIST가 작은게 가장 앞으로 와 있다. 

1. 가장 가까운 거리를 갖고 있는 변수 NN를 무한으로 초기화한다.
2. 루트부터 시작하여 깊이 우선 방식으로 R 트리를 탐색한다.
   각 인덱스 노드에서 모든 MBR을 정렬 기준(ordering metric)을 사용하여 정렬하고 ABL에 넣는다.
- 각 노드는 적은 수의 엔트리를 갖는 자체 ABL을 유지한다.
3. ABL에 가지치기 규칙 1과 2를 적용한다.
4. ABL이 비어 있을 때까지 순서대로 MBB을 방문한다.
5. 리프 노드인 경우, 실제 거리를 계산하고, 지금까지 가장 가까운 이웃(NN)과 비교하고, 필요한 경우 업데이트한다.
6. 재귀에서 복귀할 때 가지치기 규칙 3을 사용한다.
7. ABL이 비어 있으면 현재 최근접 이웃(NN)을 반환한다.

### 5) 예시
아래의 그림을 보자.

![img.png](/assets/blog/database/spacial_database/r_tree_knn/img_5.png)

위와 같이 MBB가 구성이되어있고, 아래는 해당 모양대로 R 트리를 구성한 것이다.

![img_1.png](/assets/blog/database/spacial_database/r_tree_knn/img_6.png)

기본적으로 DFS의 형태로 탐색을 하기 때문에 N1 노드부터 탐색한다.

1. E1은 QUERY로부터 거리가 1이고, E2는 거리가 루트 2이다. 따라서 E1부터 탐색한다.
2. E3, E4, E5가 있는데 MINDIST 거리만 보면 E3, E5가 같고, E4가 같으므로 E3, E5 ,E4 순으로 ABL에 들어간다.
3. E3에서 a,b,c가 있는데 a가 가장 가까우므로 a를 변수 NN은 a가 들어간다.
4. E5에서 d,e가 있는데 a가 더 가까우므로 a가 여전히 NN이다.
5. E4의 MINDIST는 a보다 길게 되었으므로 가지치기 된다.
6. 루트 노드로 올라가게 되고 E2를 탐색하게 된다.
7. E2는 E6, E7이 있는데 E6이 가까우므로 E6, E7순으로 ABL에 들어간다.
8. E6을 탐색하게 되고 i,j,k가 있는데 i가 가장 가깝고 a값보다 i가 더 가까우므로 NN은 i로 교체된다.
9. i의 거리가 E7의 MINDIST보다 짧으므로 가지치기된다.
10. 모든 ABL 큐가 비었으므로 NN인 i를 반환한다.

### 6) K-NN 확장
꼭 최근접 이웃 한개가 아닌 K개의 최근접 이웃이 필요할 수도 있다. 그렇다면 위 4)번 알고리즘을 아래와 같이 변경하면 된다.

1. 거리를 키로 하는 우선 순위 큐(NQ)를 만들고 거리가 무한인 값을 하나 넣어둔다.
2. 루트부터 시작하여 깊이 우선 방식으로 R 트리를 탐색한다.
   각 인덱스 노드에서 모든 MBR을 정렬 기준(ordering metric)을 사용하여 정렬하고 ABL에 넣는다.
- 각 노드는 적은 수의 엔트리를 갖는 자체 ABL을 유지한다.
3. ABL에 가지치기 규칙 1과 2를 적용한다.
4. ABL이 비어 있을 때까지 순서대로 MBR을 방문한다.
5. 리프 노드인 경우, 실제 거리를 계산하고, NQ의 루트인 지금까지 가장 가까운 이웃(NN)과 비교하고, 필요한 경우 NQ에 삽입한다.
6. 재귀에서 복귀할 때 가지치기 규칙 3을 사용한다.
7. ABL이 비어 있으면 필요한 K개 만큼 NQ에서 POP한다.

> 추가 업데이트 예정
{: .prompt-tip }

## 4. Best-First
1999년 Hellerstein과 Stonebraker가 제안한 방식으로 각 노드마다 ABL 큐가 있는 방식과 달리 글로벌 우선순위 큐 하나만 유지하는 방식이다.   
Branch bound 방식이 DFS에 가까웠따면 Best-first 방식은 BFS에 가까운 방식이다.

### 1) 알고리즘
1. 글로벌 힙 H(priority queue)을 만드는데, 키는 각 엔트리(인덱스 엔트리 또는 객체)에 대한 MINDIST이다.
2. 초기화: 힙 H에 루트 엔트리(root)를 넣는다.
3. H가 비어있지 않다면 힙에서 MINDIST가 가장 작은 항목을 꺼낸다.
4. 그 항목이 인덱스 엔트리(내부 노드) 이면, 그 엔트리의 자식들(즉 자식 MBR들 또는 자식 엔트리들)을 힙에 삽입한다(각자 MINDIST 계산하여 키로 사용).
5. 그 항목이 객체(데이터 포인트) 이면, 이 객체를 최근접 이웃(NN) 으로 반환하고 알고리즘 종료.

### 2) 예시
3번에서 사용한 예시를 그대로 사용하도록 하겠다.
아래는 R트리이다.

![img_3.png](/assets/blog/database/spacial_database/r_tree_knn/img_7.png)

아래는 Global 우선 순위 큐의 엔트리 탐색별 전체 과정이다.

![img_2.png](/assets/blog/database/spacial_database/r_tree_knn/img_8.png)

하나하나 차근차근 설명해보겠다.   

1. 처음의 루트 노드를 탐색한다. E1,E2 중에 E1이 가까우므로 E1을 먼저 탐색한다.
2. Global 우선순위 큐(이하 GPQ)에서 E1을 빼고 E3, E4, E5를 GPQ에 넣고 MINDIST 거리순으로 정렬한다.
3. GBQ에서 E2가 가장 짧으므로 E2를 탐색한다. E2를 빼고 E6, E7을 GPQ에 넣고 MINDIST 순으로 정렬한다.
4. GBQ에서 E6가 가장 짧으므로 E6를 탐색하며 i,j,k object를 넣고 거리순으로 정렬한다.
5. 가장 앞에 있는게 i이므로 i를 반환하고 알고리즘을 종료한다.

### 3) K-NN 확장
Best-first는 K-NN 확장이 더 쉽다. K-NN 알고리즘은 아래와 같다.

1. 글로벌 힙 H(priority queue)을 만드는데, 키는 각 엔트리(인덱스 엔트리 또는 객체)에 대한 MINDIST이다.
2. 초기화: 힙 H에 루트 엔트리(root)를 넣는다.
3. H가 비어있지 않다면 힙에서 MINDIST가 가장 작은 항목을 꺼낸다.
4. 그 항목이 인덱스 엔트리(내부 노드) 이면, 그 엔트리의 자식들(즉 자식 MBR들 또는 자식 엔트리들)을 힙에 삽입한다(각자 MINDIST 계산하여 키로 사용).
5. 그 항목이 객체(데이터 포인트) 이면, 이 객체를 최근접 이웃(NN) 중 하나로 반환한다. 이를 K개 반환할때까지 다시 반복한다.

## 5. Full Blown Algorithm
Full-Blown 알고리즘은 MINDIST를 기준으로 우선순위 큐(H)를 유지하면서, 동시에 MINMAXDIST를 이용해 현재 가능한 상한(δ)을 점점 좁혀가며
MBR(엔트리)들을 적극적으로 가지치기하는 R-tree 기반의 branch-and-bound 방식이다.

### 1) 알고리즘
1. 글로벌 힙 H(priority queue)을 만드는데, 키는 각 엔트리(인덱스 엔트리 또는 객체)에 대한 MINDIST이다.
2. 초기: H에 루트 엔트리 삽입한다. 가장 작은 MINDIST 엔트리가 앞으로 온다.
3. δ ← +∞ 현재 알고 있는 NN 거리의 상한으로 처음엔 무한대이다.
4. H가 비어있지 않다면 힙에서 MINDIST가 최소인 항목인 e를 꺼낸다.
5. 만약 e가 객체(object) 면 그 객체를 NN으로 반환하고 종료한다.
6. 그렇지 않고 e가 페이지(node)(인덱스 엔트리)면 페이지 PAGE(e) 안의 각 엔트리 se에 대해 MINDIST(q,se) ≤ δ 인 것들만 골라 H에 삽입한다.
7. 그리고 (가능하면) δ를 MINMAXDIST(q,se)로 감소시킨다(즉 δ←min(δ,MINMAXDIST(q,se)) ).
8. e가 객체가 나올때까지 반복한다.

> 추가 업데이트 예정
{: .prompt-tip }

# 참고자료
- Shashi Shekhar and Sanjay Chawla, Spatial Databases: A Tour, Prentice Hall, 2003
- P. RIigaux, M. Scholl, and A. Voisard, SPATIAL DATABASES With Application to GIS, Morgan Kaufmann Publishers, 2002
