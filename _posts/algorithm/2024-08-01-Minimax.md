---
title: Mini Max 알고리즘
author: blakewoo
date: 2024-8-3 22:00:00 +0900
categories: [Algorithm]
tags: [Computer science, Algorithm, AI] 
render_with_liquid: false
---

# Mini Max 알고리즘

상대방과 번갈아가면서 수를 두는 형태로 겨루는 게임의 AI를 짜는데 자주 사용되는 알고리즘이다.   
최선의 수를 두었을 때의 이득을 계산하는 것이 아닌 실패했을 때 손실을 최소로하는 방향으로
탐색하는 방식이다. 영어로는 Minimax algorithm, 한국어로는 최소최대 알고리즘이라고 한다.

해당 알고리즘을 사용할 수 있는 게임의 룰은 아래와 같다.

1. 둘이 하는 게임이어야한다.
2. 차례대로 수를 두는 게임이어야한다.
3. 제로섬 게임 - 둘 중 한 명은 패배한다.


게임에 참가하는 둘을 각각 minimizer와 maximizer로 정한다.
여기서 무엇을 최소화하고 무엇을 최대화하는 지는 각 상황에서의 평가함수로 상황을 정의한 값이다.
높을수록 maximizer가 유리하고, 작을 수록 minimizer에게 유리한 것이다.

![img.png](/assets/blog/algorithm/minimax/minimax_example_img1.png)

기본적으로 루트노드에서 DFS로 하나씩 탐색하여 부모노드로 값을 올리는데,
각각 턴마다 minimizer일때는 값을 최소로 올리고, maximizer는 값을 최대로 올린다.
따라서 위의 그림의 경우 결국에는 아래의 그림과 같은 형태가 된다.

![img_1.png](/assets/blog/algorithm/minimax/minimax_example_img2.png)

이렇게 되면 어떤 게임이든 간에 이렇게 탐색할 수 있으면 필승법이 있는 것 아니냐라고 할 수 있다.
틀린 말은 아니다. 모든 경우의 수를 다 파악할 수 있고 해당 부분에서 위의 탐색 트리와 같이
최상의 것만 취한다면 필승법은 항상 존재한다.
하지만 여기서 이야기하지 않은 것은 이런 게임의 경우 기본적으로 탐색 개수가 매우 많다는 것이다.

실질적인 예시로 가장 많이 사용되는 것은 틱택토 게임이라는 것이다.
3x3 판에서 O와 X를 서로 번갈아가면서 판에 긋는 게임으로 한 줄이 완성되면 이기는 게임이다.   
이렇게 단순한 게임만 하더라도 탐색해야하는 모든 경우의 수는 9!= 9x8x7x6x5x4x3x2x1 = 362,880개이다.
하물면 체스나 바둑은 말할 것도 없이 경우의 수가 매우 커지기에 모든 경우의 수를 탐색하는건 불가능에 가깝다.
따라서 탐색의 최대치를 제한하는 식으로 유한 시간내에 결과를 내는 방식을 택하며 이 최대치를 얼마나 늘리느냐에 따라   
해당 알고리즘의 승률이 올라간다고 볼 수 있다.


# 참고 자료
- [[인공지능] 게임 트리 - 미니맥스(minimax) 알고리즘, 알파베타 가지치기, 휴리스틱 평가 함수(evaluation function)](https://ssollacc.tistory.com/43)
- [Mini-Max Algorithm in Artificial Intelligence](https://www.javatpoint.com/mini-max-algorithm-in-ai)
