---
title: JPS 알고리즘
author: blakewoo
date: 2024-7-27 15:30:00 +0900
categories: [Algorithm]
tags: [Computer science, Algorithm] 
render_with_liquid: false
use_math: true
---

# JPS 알고리즘

## 개요
이전에 우리는 A* 알고리즘에 대해서 공부해보았다.   
하지만 이러한 A* 알고리즘 역시 기본적으로 BFS에 가까운 알고리즘이고 매칸 마다 그다음 노드들을
탐색해야하기에 너무나 많은 시간이 걸린다.

![img_13.png](/assets/blog/algorithm/a_star/img_13.png)

이전 시간에 포스팅한 A* 알고리즘으로 탐색한 내용이다. 보면 알겠지만 BFS로 전체를 탐색한 것과
크게 차이가 나지 않아보인다. (물론 예시를 제대로 만들지 못한 것도 있겠지만)

그래서 이렇게 느린 A* 알고리즘의 문제점을 수정한 JPS(Jump Point Search)라는 알고리즘이
2011년에 Daniel Harabor과 Alban Grastien이라는 사람에 의해 만들어졌다.   
이 JPS 알고리즘은 기존 A* 알고리즘의 10배의 성능을 자랑한다.   
이 알고리즘은 노드 간의 거리가 별도의 에지로 나타난 형태의 그래프가 아닌
가로 세로 길이가 일정한 형태의 그리드 맵 형태에서 그 진가를 자랑하는데
이러한 그리드 맵에서 JPS 알고리즘은 체감상 A* 보다 10배 이상의 성능을 느낄 수 있다.

## 알고리즘 구동 방식

### 기본 탐색 원리
특정 노드 한칸을 이동한다고 할때 이미 지나온 노드를 P라고 하고 현재 노드 탐색중인
노드를 X라 하자. 그럴때 A * 알고리즘의 경우 노드 한 칸을 이동할때마다 8칸 모두를 체크한다.
하지만 JPS에서는 다른 방식의 기본 탐색을 제안했다.

![img_5.png](/assets/blog/algorithm/jps/img_5.png)
P는 이미 지나온 노드이니 탐색 대상에서 제외한다.

![img_2.png](/assets/blog/algorithm/jps/img_2.png)   
P와 X방향에서 반대인 양 옆 노드는 신경쓰지 않는다.
P에서 X로 가기 위해서는 양 옆 노드를 거쳐서 가는 것보다 X로 직접 가는 것이
더 최적이기 때문에 그쪽으로 오지 않았을 것이므로 신경쓰지 않는다.

![img_3.png](/assets/blog/algorithm/jps/img_3.png)   
X의 양 옆 노드 역시 P에서 이동하는 것이 이동거리 2를 들인것보다 $\sqrt{2}$만 들여서
이동하는게 더 최적이다. 그렇기 때문에 다음 탐색에서 무시한다.

![img_4.png](/assets/blog/algorithm/jps/img_4.png)    
X의 대각선 방향에 위치한 노드의 경우 X의 양 옆 노드를 통해 갈 수도 있다.   
하지만 비용은 같으며 어차피 비용이 같다면 무시해도 되기 때문에 탐색 대상에서 제외해도 된다.

이러한 가정들을 해두고 탐색의 방법을 정의하니 탐색의 형태는 다음과 같이 된다.

### 기본 탐색 형태

![img.png](/assets/blog/algorithm/jps/img.png)   
위, 아래, 오른쪽, 왼쪽의 경우 그냥 한칸씩 나아가며 바로 앞이 막혔는지 체크를 하면 되지만
대각선의 경우 한칸 이동할때마다 수직, 수평 성분으로 분해하여 탐색이 필요하다.

![img_1.png](/assets/blog/algorithm/jps/img_1.png)   
수평과 수직방향으로 나아가는 탐색의 경우 해당 방향으로의 탐색 간 벽에 막혔다면
탐색하기에 적합한 노드는 없는 것이므로 해당 방향에 대한 탐색은 종료하면 된다.

하지만 아래와 같은 상황이 발생한다면 탐색할만한 노드가 나타난 것이므로 탐색 대상으로 넣어야한다.

![img_6.png](/assets/blog/algorithm/jps/img_6.png)

S에서 8방향으로 탐색을 하며 이동하고자 할때 중간에 검은색 벽이 가로막고 있다.   
그리고 그 뒤에는 지나갈수있는 노드이다. 이런 상황 일 경우 벽이
앞서 서술했던 전제가 틀어지게 만든다. 왜냐하면 D 포인트에 대해서 아래 길을 통해 접근할 수가 없기 때문이다.
따라서 이 벽에 대해서 추가적인 체크가 필요하다.
여기서 D점을 강제이웃(forced neighbor)이라고 부르며 해당 점에 대해서 추가적인 탐색이 필요하다.

### 강제이웃(forced neighbor)
추가적인 탐색이 필요한 점이며 사실상 탐색의 핵심이다.   
이 점을 발견한 현재 노드 기준를 열린 노드에 추가하며 강제이웃점을 기준으로
위에서 서술했던 8방향으로 직선 탐색 및 강제 이웃 탐색을 재귀적으로 진행한다.

## 알고리즘 동작 예시
사실 이렇게 말로만 설명하면 이해하기 힘들다.   
알고리즘이 어떻게 동작하는 가를 보이기 위해서 이전에 포스팅했던 길거리를 갖고 오겠다.

![img.png](/assets/blog/algorithm/a_star/a_star_map_1.png)

이 길거리는 가로 10칸 세로 8칸의 정사각형 셀들로 이루어진 길거리이다.
이전에는 그래프로 단순화 시켰지만 JPS의 경우 그리드 맵 형태가 가장 효율적이므로 맵을 그래프 형태로 바꾸진 않겠다.   
해당 맵에서 JPS를 구동하면 아래와 같은 형태로 경로가 나온다.

![img_7.png](/assets/blog/algorithm/jps/img_7.png)

초록색 노드가 시작점이고 붉은색 노드가 도착점이다.   
보라색으로 보이는 부분은 열린 노드로 추가된 부분이며 해당 열린 노드에서 강제 이웃으로 8방향으로
탐색을 진행하면 결국에는 도착점에 도달하게 된다.



# 참고 자료
- D. Harabor; A. Grastien (2011). Online Graph Pruning for Pathfinding on Grid Maps. 25th National Conference on Artificial Intelligence. AAAI.
- [zerowidth positive lookahead - A Visual Explanation of Jump Point Search](https://zerowidth.com/2013/a-visual-explanation-of-jump-point-search/)
