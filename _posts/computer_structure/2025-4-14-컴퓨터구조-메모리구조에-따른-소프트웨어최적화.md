---
title: 컴퓨터 구조 - 메모리 구조에 따른 소프트웨어 최적화
author: blakewoo
date: 2025-4-20 18:00:00 +0900
categories: [Computer structure]
tags: [Computer structure, CPU, Memory, Optimization] 
render_with_liquid: false
use_math: true
---

# 메모리 구조에 따른 소프트웨어 최적화
## 1. 개요
최근 컴파일러에는 대부분 포함되어있는 내용이다. 메모리 구조와 Cache 구조에 따른 최적화 기법인데, 
기본적으로 아래의 목적을 가지고 실행 된다.

- Temporal locality 증가
- Spatial locality 증가
- Conflict 제거

위 세 가지를 만족하는 방향으로 조정하면 성능이 올라가게 된다. 여기서 성능이 올라간다는 것은
응답 시간이 줄어든 다는 뜻이다.   
코드 최적화란 위 세 가지를 목표로 원래 코드에서 메모리 layout과 접근 순서를 변경함으로써 성능을 높이는 것이다.

## 2. 효과적인 코드를 만드는 절차
### 1) 좋은 알고리즘을 사용한다.
어떤 배열을 정렬한다고 해보자. bubble sort와 quick sort로만 비교해도 엄청나게 차이나는 것을 알 수 있다.

### 2) 효과적인 라이브러리를 사용한다.
유명한 라이브러리들은 대부분 좋은 알고리즘을 사용한다. 특히 해당 머신에 특화되어 최적화되어있는 경우도 많다.

### 3) 적절한 컴파일러와 옵션을 사용한다.
기본값으로 어느정도 최적화를 지원하는 것도 있고 별도의 옵션으로 지원하기도 한다.   
실제로 동일한 c 코드를 놓고 visual studio에서 빌드를 했을 때 기본값으로 빌드하는 것과
완전 최적화 옵션을 끄고 빌드하면 생성된 바이너리 코드가 다른 것을 알 수 있다.

### 4) 코드를 수동으로 최적화 한다.
예전 방식이다. 하지만 여전히 효과적이고 프로그래머의 실력에 좌우된다.

### 3. 반복문 최적화
기본적으로 캐시 최적화라고하면 Loop와 Array에서 진행된다.
이는 Locality를 잘 살릴 수 있고, 이를 통해 성능 이득을 보기 쉽기 때문이다.   
모든 최적화가 그렇지만 바꾼 코드가 이전 코드와 동일한 결과를 출력하는지는 좀 봐야한다.

#### 1) Loop Interchange

```C
// Loop 1
char a[N][N];
for(j=0;j<N;j++) {
  for (i<0;i<N;i++) {
    a[i][j]++;
  }
}
```
위의 코드는 Spatial Locality 면에서 볼때 매우 좋지 않다.
이는 위의 코드의 메모리 엑세스 패턴이 아래와 같기 때문이다.

![img.png](/assets/blog/cs/cpu_structure/optimization/img.png)

회색 음영으로 칠한 부분이 Cache miss로 인해 갖고 온 블럭이라고 할 때 갖고온 Cache 부분이 아닌
다른 부분을 접근하기 때문에 또 Cache miss가 나게 된다.    
위와 같은 형태라면 100% Cache miss가 나게 된다. (5번에 엑세스할때쯤 이미 캐시가 Replacement 되어있을 가능성이 있기 때문에)    
따라서 행동은 동일하되 빠른 성능을 위해서는 아래와 같이 코드를 바꿔야한다.

```C
// Loop 1
char a[N][N];
for(i=0;i<N;i++) {
  for (j<0;j<N;j++) {
    a[i][j]++;
  }
}
```

![img_1.png](/assets/blog/cs/cpu_structure/optimization/img_1.png)

회색 음영이 갖고 온 캐시라고 할때 접근 순서와 동일하게 맞아떨지는 것을 알수 있으며
100% Cache miss때와는 다르게 Cache hit가 어느정도 일어나기 때문에 성능이 더 향상된다.

#### 2) Loop Fusion

```C
for(i=0;i<N;i++)
  a[i] = b[i] + 1;
for(i=0;i<N;i++)
  c[i] = 3*b[i];
```

위의 코드의 경우 두 개의 loop간에 Temporal Locality 를 전혀 쓸 수 없다.   
자세히보면 첫번째 루프의 b[i]와 두번째 루프의 3*b[i]는 동일한 인덱스이기 때문에
Temploral Locality를 살릴 수 있는데 말이다.

따라서 성능 향상을 위해 아래와 같이 바꿀 수 있다.

```C
for(i=0;i<N;i++) {
  a[i] = b[i] + 1;
  c[i] = 3*b[i];
}
```

#### 3) Loop Reversal
```C
for(i=0;i<N;i++) {
  a[i] = b[i] + 1;
  c[i] = 3*b[i];
}
for(i=0;i<N;i++)
  d[i] + c[i+1] + 1;
```

이전의 Index에서 처리한 값이 이후 Index에서 처리될 값에 영향을 주지 않는다
(즉, loop carried dependency 가 없다) 따라서 순서를 바꿔도 상관없으며
Cache Miss 또한 영향을 받지 않는다. (block 끝부분에서 갖고 올것이므로)

```C
for(i=N-1;i>=0;i--) {
  a[i] = b[i] + 1;
  c[i] = 3*b[i];
}
for(i=N-1;i>=0;i--)
  d[i] + c[i+1] + 1;
```

일단 분리하기는 했으나 cache의 way만 충분하고 초기값 처리만 해준다면 두 개의 loop를 합쳐도 무방할 것이다.

#### 4) Loop Fission
```C
for(i=0;i<N;i++) {
  a[i] = b[i] + 1;
  c[i] = 3*a[i];
  f[i] + g[i] + h[i];
}
```

만약 4-way cache를 쓰고 있다고 가정해보자.   
동일한 Index의 값들을 동일한 cache index에 위치할 가능성이 높다.   
따라서 위와 같이 4개를 넘어서는 변수는 4-way cache내에서 conflict miss를 일으킬수 있다.
이런 경우 차라리 Loop를 분할 해주면 cache conflict 없이 오히려 성능이 항샹 될 수 있다.

```C
for(i=0;i<N;i++) {
  a[i] = b[i] + 1;
  c[i] = 3*a[i];
}
for(i=0;i<N;i++)
  f[i] + g[i] + h[i];

```

#### 5) Loop Unrolling
Loop를 뜯는 행동이다. 아래의 코드를 보자.   
```c
for (i=0;i<100;i++)
  a[i] = b[i] + c;
```

위 코드를 아래로 뜯는 것이다.

```c
for (i=0;i<100;i++) {
  a[i] = b[i] + c;
  a[i+1] = b[i+1] + c;
}
```

위와 같은 경우 여러가지 이득과 손해가 있다.

##### a. 이득
- Loop overhead가 줄어든다(branch taken에 대한 계산과 index 계산등)
- 명령어가 늘어나기 때문에 현대 superscalar 머신에서 좀더 효율적이다.

##### b. 손해와 한계
- Renaming을 위한 더 많은 레지스터가 필요하다.
- 코드 사이즈가 커진다(용량을 많이 먹음)
- loop carried dependency는 해결할 수 없다.
- loop내에 if가 있으면 성능이 떨어진다.



### 4. 배열 최적화
#### 1) Array Merging
아래의 코드를 보자
```C
int a[N], b[N], c[N]
for(i=0;i<N;i++)
  a[i] = b[i] + c[i];
```

위와 같이 배열을 잡을 경우 연산과 배열 할당에 문제가 생길 수 있다.
가령 N이 3이고, 캐시에서 한번에 가져올때 4 x sizeof(int)를 가져온다고 가정해보자.

![img_2.png](/assets/blog/cs/cpu_structure/optimization/img_2.png)

연산은 0부터 해야하는데 B0까지는 있다고 해도 C0는 다시 갖고 와야한다.   
매우 비효율적이다. 따라서 아래와 같이 할당해두면 좀 더 효율적이다.

```C
struct ALL {int a,b,c};
struct ALL M[N]
int a[N], b[N], c[N]
for(i=0;i<N;i++)
  M[i].a = M[i].b + M[i].c;
```

![img_3.png](/assets/blog/cs/cpu_structure/optimization/img_3.png)

Spatial Locality가 증가했음을 알 수 있다.

#### 2) Array Padding
기본적으로 컴퓨터의 메모리 구조는 align을 맞추면 좋다.  
하지만 Cache 입장에서는 아닐 수 있다.
아래의 코드를 보자

```c
int a[N], b[N];
for(i =0 ;i<N;i++)
  sum += a[i]*b[i];
```

이 코드가 뭐가 문제인데 할 수 있다.   
일단 L1 cache가 2-way면 문제가 없다. 하지만 대부분 L1 Cache의 경우 빨라야하기 때문에
Direct mapped cache 방식을 차용한다.   
그렇게 되면 동일한 index를 가진 값들은 conflict miss가 날수 있다.  
따라서 a와 b값의 할당시 약간의 틀어짐을 추가해주면 cache miss가 나지 않을 수 있다.

```c
int A[N], pad[8], B[N];
for(i =0 ;i<N;i++)
  sum += a[i]*b[i];
```

32bytes 만으로 캐시 miss를 줄일 수 있다면 꽤 싸게 먹히는 것 같다.

### 5. 행렬 곱셈 최적화
> ※ 추가 업데이트 및 검증 예정이고, 올라간 부분도 아직 완벽하지 않으니 참고만 바란다.
{: .prompt-tip }


# 참고자료
- Computer Organization and Design-The hardware/software interface, 5th edition, Patterson, Hennessy, Elsevier
- 서강대학교 이혁준 교수님 강의자료 - 고급 컴퓨터 구조
