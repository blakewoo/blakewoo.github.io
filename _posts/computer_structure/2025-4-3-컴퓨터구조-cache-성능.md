---
title: 컴퓨터 구조 - CPU 구조 - Cache 성능
author: blakewoo
date: 2025-4-6 16:00:00 +0900
categories: [Computer structure]
tags: [Computer structure, CPU, Cache, Memory] 
render_with_liquid: false
use_math: true
---

# Cache 성능
## 1. 개요
기본적으로 Memory에 대한 성능을 이야기 할때 AMAT(Average Memory Access Time)를 가지고 말한다.
이 AMAT는 아래와 같이 산출한다.

$$ AMAT = Hit Time + Miss Rate + Miss Penalty $$

- Hit Time : Cache에 data가 있고 이 데이터를 갖고 오기까지의 시간을 말한다.
- Miss Rate : Cache에 접근시 어느정도 비율로 Cache miss가 나는지를 말한다. 
- Miss Penalty : Cache miss가 발생시 하위 메모리 층에서 데이터를 갖고 오는 시간을 말한다.

따라서 성능이 높다는 것은 AMAT이 작다는 뜻이고, 이 AMAT을 줄이기 위해서는 위 세 요소를 줄여야하는 것이다.

## 2. Cache miss
Hit Time 이전에 Cache miss에 대해서 알아보도록 하겠다.    
일반적으로 우리가 Cache miss라 부르는 것은 사실 총 3가지 경우가 있다.

### 1) Compulsory or cold misses
프로그램 시작시 모든 Cache가 비어있기 때문에 어쩔수없이 발생하는 Cache miss이다.   
피할수 없기 때문에 Compulsory 혹은 Cold(예열되지 않았음) miss로 불린다.   
이런 경우는 미리 Cache에 데이터를 넣어두면 피할 수 있다. 이를 pre-fetch라고 한다.

### 2) Conflict or interference misses
대상 Index에 목표하는 데이터가 아닌 다른 데이터가 점유하고 있어서 Conflict로 인해 발생하는 Cache miss이다.    
hashing collision 문제와 비슷하다고 생각하면 된다.   
이는 Cache를 associativity 하게 구성하면 conflict 가 덜 발생하게 된다.

### 3) Capacity misses
Cache 용량이 크지 않아서 생기는 문제이다.   
어차피 Cold misses 제외하고는 Cache 크기가 작아서 생기는 문제가 아닌가? 할 수 있겠지만 좀 다르다.   
정확하게는 Cache가 Working set, 즉 프로그램을 구동할때 필요한 최소한의 명령어와 데이터를 다 담지 못하기 때문에
발생하는 문제이다.   
이는 Cache 용량을 늘리거나, 데이터의 양을 줄이면 해결된다.

### ※ Capacity misses와 Conflict misses를 구분하는 법
그럼에도 불구하고 현재 발생중인 Cache miss가 Capacity misses인지 Conflict misses인지 헷갈린다면,
현재 구동중인 Cache 구조가 Fully associative cache라고 생각해봤을때도 해당 문제가 발생한다면
이는 Capacity misses인 것이다.

## 3. Cache block
### 1) Cache block 크기와 Address의 상관 관계
여기서 말하는 Block이란 Cache의 실질적인 Data가 담겨있는 곳의 크기를 말한다.   
그리고 Cache miss시에 메모리에서 한번에 읽어오는 크기를 말하기도 한다. 
Cache block에 대한 크기는 Address와 Tag bit와 Index bit, 그리고 전체 bit만 주면 유추해볼 수 있다.    
예를 들어 가령 아래와 같은 구조라고 해보자.   

- 총 Address bit : 32
- Tag bit : 20
- Index bit : 8
- byte offset bit : 4

Direct Mapped Cache라고 할 때, block의 크기는 어떻게 되며 총 Cache의 크기는 어떻게 될까?   
먼저 block의 크기는 간단한데 bit offset의 크기를 승수로 계산하면 된다.

$$ 2^{4} = 16 $$

총 16bytes의 크기이며, 1 word를 4bytes라고 한다면 4 word만큼 들어갈 수 있다.    
캐시 block 크기를 산정했으니 총 Cache Data의 크기도 산정해볼 수 있다.   
index만큼 cache 블럭 수가 있기 때문이다.   

$$ 2^{8} = 256 $$

총 256개의 블럭이 있고 블럭마다 사이즈가 16bytes이니

$$ 256 \times 16 = 4096 = 4 \times 1024 = 4KB $$

Cache의 총 Data block는 4KB가 되는 것이다.

### 2) Cache block과 성능
이 Cache block의 크기에 따라 성능이 달라진다.   
만약 Cache block이 커진다고 가정해보자. 그러면 전체 Address는 동일하고, 전체 Cache의 사이즈가 이전과 동일하다면
전체 Cache Block 수가 줄어든다. Block이 커졌기에 한번에 갖고 오는 연속 데이터가 커지니 Spatial locality 가 높은
프로그램의 경우 성능이 올라가나, Block 개수가 줄었기 때문에 Temporal Locality가 높은 프로그램의 경우
성능이 저하되며 Memory bandwidth를 많이 요한다.

그렇다면 반대로 생각해서 block 사이즈가 작아진다면 어떻게 될까? 동일하게 Address, 전체 사이즈가 동일하다면
전체 Cache block 수가 많아지나, Block이 작아졌기에 Spatial Locality 가 높은 프로그램이라면 성능이 떨어지지만
Cache block의 개수가 많아졌기 때문에 Temporal Locality가 높은 프로그램이라면 오히려 성능이 올라갈 수 있다.

이를 그림으로 그려보면 아래와 같다.

![img.png](/assets/blog/cs/cpu_structure/cache/performance/img.png)

Block 사이즈가 커지면 Miss Rate가 내려가다가 일정 지점을 이후로 쭉 올라가는 걸 볼 수 있는데
이 지점이 가장 최적의 사이즈이고, 최근 일반적으로는 이 사이즈가 64Bytes로 잡혀있다.

## 4. Hit time 줄이기
> ※ 추가 업데이트 및 검증 예정이고, 올라간 부분도 아직 완벽하지 않으니 참고만 바란다.
{: .prompt-tip }


# 참고자료
- Computer Organization and Design-The hardware/software interface, 5th edition, Patterson, Hennessy, Elsevier
- 서강대학교 이혁준 교수님 강의자료 - 고급 컴퓨터 구조
