---
title: 컴퓨터 구조 - CPU 구조 - Cache 기초
author: blakewoo
date: 2025-4-3 16:00:00 +0900
categories: [Computer structure]
tags: [Computer structure, CPU, Cache, Memory] 
render_with_liquid: false
use_math: true
---

# Cache
## 1. 개요
캐시(Cache)란 CPU 연산에 비해 상대적으로 느린 메모리 접근 속도를 커버하기 위해 만든 임시 저장장소이다.

기본적으로 지역성(Spatial, Temporal)에 근거하여 빨라질 것이라는 기대아래 설계된 것으로,
실제로 Cache 덕분에 성능은 급격하게 올라갔다.

## 2. 캐시의 전체적인 구조
기본적으로 캐시뿐만 아니라 모든 메모리는 계층 구조로 되어있다.   
아래의 그림을 보자

![img.png](/assets/blog/cs/cpu_structure/cache/basic/img.png)

아래 표는 위 그림의 구조에 접근 시간, 용량, 그리고 관리 주체에 대한 표이다.

<table>
    <tr>
        <td>Memory Type</td>
        <td>Access Time</td>
        <td>Capacity</td>
        <td>Managed by</td>
    </tr>
    <tr>
        <td>Register</td>
        <td>1 cycle</td>
        <td>~500B</td>
        <td>Software/Compiler</td>
    </tr>
    <tr>
        <td>Level 1 Cache</td>
        <td>1~3 cycles</td>
        <td>~64KB</td>
        <td>Hardware</td>
    </tr>
    <tr>
        <td>Level 2 Cache</td>
        <td>5~10 cycles</td>
        <td>1~10MB</td>
        <td>Hardware</td>
    </tr>
    <tr>
        <td>Level 3 Cache</td>
        <td>14~80 cycles</td>
        <td>11~50MB</td>
        <td>Hardware</td>
    </tr>
    <tr>
        <td>DRAM</td>
        <td>~ 100 cycles</td>
        <td>~16GB</td>
        <td>Software/OS</td>
    </tr>
    <tr>
        <td>Disk</td>
        <td>10^6 ~ 10^7 cycles</td>
        <td>TB이상</td>
        <td>Software/OS</td>
    </tr>
</table>

레지스터 뿐만아니라, Level1 Cache, Level2 Cache, DRAM, DISK 순으로
빠르고 작은것에서 느리고 큰것으로 내려가는 것을 볼 수 있다.

## 3. hit 방식에 따른 구조

### 1) Direct-mapped
아래의 그림을 보자.

![img_2.png](/assets/blog/cs/cpu_structure/cache/basic/img_1.png)

주소는 Tag와 Index로 분할되고, byte offset은
몇 비트 아키텍처냐에 따라 달라진다. 일단 32bit 기준이라면 2비트는 offset으로 두고
index를 기준으로 찾고, 찾은게 맞는지 Tag로 검색하는 방식이다.

cache 테이블이 있고, index로 주소의 Index 영역을 사용한다.   
이후 Tag로 값을 확인한다.

가장 기초적인 방식이다. 하지만 여러 문제점이 있다.   
각 index에 대해서 하나밖에 연결이 안되니까 conflict 율이 높다.   
이는 곧 cache miss로 이어지기 때문에 별로 좋지 않다.

### 2) Fully associative

![img_2.png](/assets/blog/cs/cpu_structure/cache/basic/img_2.png)

아예 빈자리가 있으면 넣을 수 있게 만든 캐시 방식이다.   
캐시를 읽어들일때마다 전체를 다 체크하기 때문에 느리고 이런 구조는 
CAM(Content Addressable Memory)를 써야하는데 이게 비싸고 복잡하다.

### 3) Set associative

![img_3.png](/assets/blog/cs/cpu_structure/cache/basic/img_3.png)

위와 같이 각 Index별로 몇 가지를 두는 것이다. 이렇게 되면 Direct Mapped cache에 비해
conflict도 적어지고 conflict가 적어지니 hit 율도 많이 올라간다.

## 4. 메모리 동기화에 따른 구조

### 1) Write Back
캐시에만 기재하는 방식이다.
이후 기재되어 바뀐 캐시가 Replacement 될때 메모리에 써지고
Cache에서 데이터가 없어진다.

### 2) Write Through
캐시와 메모리 둘 다 기재하는 방식이다.  
어떤 데이터를 수정해야할때 캐시와 메모리까지 수정하고 그다음 작업을 이어나가는 것이다.

> ※ 추가 업데이트 및 검증 예정이고, 아직 완벽하지 않으니 참고만 바란다.
{: .prompt-tip }

# 참고자료
- [Intel 아이스레이크 스펙](https://www.7-cpu.com/cpu/Ice_Lake.html)
- Computer Organization and Design-The hardware/software interface, 5th edition, Patterson, Hennessy, Elsevier
- 서강대학교 이혁준 교수님 강의자료 - 고급 컴퓨터 구조
