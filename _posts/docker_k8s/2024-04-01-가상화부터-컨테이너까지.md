---
title: 가상화부터 컨테이너까지
author: blakewoo
date: 2024-4-1 23:30:00 +0900
categories: [Docker & K8s]
tags: [docker,k8s]
render_with_liquid: false
---

가상화라는게 없던 시절 서버 당 한 개의 어플리케이션이 구동되던 시기가 있었다.
물론 서로 충돌하지 않으면 여러 개를 돌려도 괜찮지 않나? 하고 생각할 수도 있겠지만
Product level의 서비스를 제공하면서 그렇게 서비스를 제공한다는건 가용성으로나 운영적으로나 보안적으로나
바람직하지 못한 일이었기에 서버당 한 개의 어플리케이션이 권장되던 시기였다.

이렇게 서버를 통해서 서비스를 제공하던 그 시기에는 하드웨어가 폭발적으로 성장하던 시기였다.
인텔의 공동 창업자 골든 무어가 발표한 무어의 법칙 (메모리의 용량이나 CPU의 속도가
약 24개월마다 2배로 증가하고, 가격은 2배씩 낮아진다는 법칙)의 말 처럼 소프트웨어가 하드웨어의 발달을
따라가기 어려운 시기였으며 그 때문에 서버 성능의 10%까지 밖에 사용하지 못하던 시기였다.
많은 돈을 들여 서버를 들여놓았더니 어플리케이션 사용량이 많지 않아 하드웨어가 놀고 있다니
회사 입장에서는 곤란한 일이었다. 그러던 와중에 등장한 것이 바로 하드웨어 가상화 기술이다.

# 가상화
가상화 기술은 간단히 말해서 여러 개의 OS에 한 개의 하드웨어를 마치 여러 개의 하드웨어인것마냥 제공하는 기술입니다.
컴퓨터 한 대를 여러 대인 것처럼 사용하는 기술이라고 생각해도 된다.
이러한 가상화를 해줄 수 있게 해주는 주체를 hypervisor라고 한다.

최초의 가상화는 IBM에서 시작되었습니다. 1960년대에 CP-40이라는 이름의 하이퍼바이저를 시작으로
2001년에 VM workstation, 2003년에 citrix의 xen까지 2000년대 초에 등장하기 시작했는데
당연하지만 이런 가상화에도 종류가 있다.

## 가상화의 종류

### Type 1
Host OS가 없는 형태로 하드웨어 바로 위에 Hypervisor 올라가 있는 형태로 hypervisor위에
Guest OS가 올라가서 구동되는 형태다. 이 경우에도 두 가지로 나뉜다.

#### 전 가상화   
![img.png](/assets/blog/docker&k8s/type_one_virtualization_fully_img.png)   
가상 머신에 설치된 운영체제들은 하드웨어 관련 작업을 할 때 해당 요청을 하이퍼바이저에게 보내고
하이퍼바이저가 OS 요청을 받아 하드웨어에게 전달한다.   
- 장점 : OS 소스코드 수정 없이 그대로 사용가능함  
- 단점 : 모든 요청이 하드웨어로 바로 가는 것이 아닌 Hypervisor를 통해서 가므로 느리다.

#### 반 가상화     
![img_1.png](/assets/blog/docker&k8s/type_one_virtualization_half_img.png)   
각 Guest OS가 돌아가는 가상머신에서 직접 하드웨어와 통신하는 방식이다.
전 가상화와는 달리 모든 명령을 하이퍼바이저를 완전 중재하는 것이 아니라
하이퍼바이저 명령을 추가하는 정도로 처리해서 하드웨어와 통신한다.   
- 장점 : 전 가상화에 비해서 빠르다.  
- 단점 : 하이퍼바이저에게 요청을 할 수 있도록 각 OS의 커널을 수정해야하기에 오픈소스 OS가 아니면
반가상화를 이용하기가 쉽지 않음

### Type 2    
![img.png](/assets/blog/docker&k8s/type_two_virtualization_img.png)   
   

HOST OS가 있고 그 위에 Hypervisor가 올라간 뒤 그 위에 guest OS가 올라가서 구동되는 형태이다.

- 장점 : 가상의 하드웨어를 에뮬레이팅하는 방식으로 호스트 운영체제에 따른 제약사항이 크게 없음
- 단점 : OS위에 OS를 에뮬레이팅해서 돌아가는 방식이기에 오버헤드가 큼

# 컨테이너
구글에서 남는 컴퓨팅 자원을 클라우드 서비스로 제공하자는 제안으로 인해 GCP가 생기고 아마존에서
AWS가 생기면서 클라우드 서비스가 폭발적으로 발달했고 그로 인해 가상화 기술도 발달했지만
이런 가상화 기술도 문제가 많았다.
VM마다 GUEST OS가 올라가기 때문에 이러한 OS를 구동하기 위해 드는 자원이 너무 큰 것이 대표적인 문제였는데
OS가 메모리에 상주하는 부분이 컸기 때문에 RAM을 너무 많이 써서 문제가 되었다. 동일한 OS를 쓰고 있다면
다른 어플리케이션을 쓴다는 이유만으로 OS에 대한 내용을 중복으로 갖고 있는 것이어서 문제가 더욱 컸다.

그래서 연구원들이 생각했다.   
```
격리에 대해서만 제대로 구현할 수 있으면 OS까지 가상화할 필요는 없는 것 아닌가?
```
이러한 이유로 Linux에서 컨테이너라는 개념이 도입되었고 이러한 개념을 뒷받침하기 위해
namespace, cgroup, chroot등 많은 기능이 개발되었다. (이러한 부분은 도커의 구조에 대해서
말하면서 다시 논하겠다)
그리고 이 기능들을 묶어서 Linux에서는 LXC(LinuX Containers)라는 컨테이너로 제공했다.

# 도커의 탄생
LXC는 리눅스에서만 사용가능했다. 그런데 LINUX에서만이 아닌 플랫폼 종속적이지 않게
컨테이너 환경을 제공하고 싶은 사람들이 있었는데, 이런 사람들이 만든게 현재 아주 많은 사람들이 쓰고 있는
컨테이너인 DOCKER이다.   
처음에는 DOCKER도 LXC를 통해 컨테이너 환경을 제공했으나 이후 플랫폼 종속적이지 않은 기능 제공을 위해
libcontainer라는 독자적인 툴을 개발했고 이런 툴로써 컨테이너를 제공함으로써 자기들이 원하던 
멀티 플랫폼에서의 서비스를 구현할 수 있었다.

이 다음에는 이러한 도커가 어떤 구조인지 어떤 기능을 제공하는지에 대해서 알아볼 생각이다.


# 참고 자료
- https://selog.tistory.com/entry/%EA%B0%80%EC%83%81%ED%99%94-%EA%B0%80%EC%83%81%ED%99%94Virtualization%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD%EA%B3%BC-%EB%B0%9C%EC%A0%84
- https://csj000714.tistory.com/641 
- https://gngsn.tistory.com/128
