---
title: 부트로더 - 10
author: blakewoo
date: 2024-2-16 23:15:00 +0900
categories: [OS]
tags: [OS]
render_with_liquid: false
---

지난 번에 이어서 포스팅을 계속하도록 하겠다.

```
	/* Print message string */
#define MSG(x)	movw $x, %si; call LOCAL(message)
#define ERR(x)	movw $x, %si; jmp LOCAL(error_message)
```
c에서 많이 쓰이는 방식의 매크로다. gcc를 이용하여 어셈블리어를 컴파일하기 때문에
이러한 전처리 매크로가 사용가능하다.
MSG 출력시에는 LOCAL(message) 라벨을 call하고
에러시에는 LOCAL(error_message) 라벨로 jmp하라는 뜻이다.
x 값에 따라 메세지가 달라진다.

```
	.macro floppy
```
.macro는 일종의 매크로로, .macro 다음의 식별자를 지정하는데
해당 식별자를 쓰면 정의된 대로 대체해주는 것이다.
다음의 floppy 식별자가 나오면 아래에 .endm이 나올때까지의 코드를 변경해준다.
```
part_start:

LOCAL(probe_values):
	.byte	36, 18, 15, 9, 0

LOCAL(floppy_probe):
	pushw	%dx
/*
 *  Perform floppy probe.
 */
#ifdef __APPLE__
	LOCAL(probe_values_minus_one) = LOCAL(probe_values) - 1
	movw	MACRO_DOLLAR(LOCAL(probe_values_minus_one)), %si
#else
	movw	MACRO_DOLLAR(LOCAL(probe_values)) - 1, %si
#endif
```
\#ifdef의 경우 다음 조건문이 만족하면 해당 코드를 컴파일할때 쓰는 식인데
다음과 같이 __APPLE__이라고 되어있는 것의 뜻은 __APPLE__이 사전에 정의가 되어있다면
이라는 뜻으로 이전에 include한 header에 __APPLE__값이 있다면 해당 매크로 대로 처리하라는 뜻이다. 

```
LOCAL(probe_loop):
	/* reset floppy controller INT 13h AH=0 */
	xorw	%ax, %ax
	int	MACRO_DOLLAR(0x13)

	incw	%si
	movb	(%si), %cl

	/* if number of sectors is 0, display error and die */
	testb	%cl, %cl
	jnz	1f

/*
 * Floppy disk probe failure.
 */
	MSG(fd_probe_error_string)
	jmp	LOCAL(general_error)

/* "Floppy" */
fd_probe_error_string:	.asciz "Floppy"

1:
	/* perform read */
	movw	MACRO_DOLLAR(GRUB_BOOT_MACHINE_BUFFER_SEG), %bx
	movw	%bx, %es
	xorw	%bx, %bx
	movw	MACRO_DOLLAR(0x201), %ax
	movb	MACRO_DOLLAR(0), %ch
	movb	MACRO_DOLLAR(0), %dh
	int	MACRO_DOLLAR(0x13)

	/* if error, jump to "LOCAL(probe_loop)" */
	jc	LOCAL(probe_loop)

	/* %cl is already the correct value! */
	movb	MACRO_DOLLAR(1), %dh
	movb	MACRO_DOLLAR(79), %ch

	jmp	LOCAL(final_init)
	.endm
```

여기까지 코드에 대한 전반적인 뜻은 floppy disk에 대한 처리 부분이다.
아직 세부적인 코드에 대한 분석이 조금 덜 끝났으니 분석이 완료된다면
이 포스팅에 추가 업데이트를 하도록 하겠다.

### 참고 문헌
1. https://git.savannah.gnu.org/git/grub.git
