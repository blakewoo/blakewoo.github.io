---
title: 모드에 대한 이해 - 3
author: blakewoo
date: 2024-1-18 22:30:00 +0900
categories: [OS]
tags: [OS]
render_with_liquid: false
---

# 보호 모드

앞서 포스팅한 내용에 따르면 보호 모드의 특성은 아래와 같다.

1. 윈도우나 Linux가 구동되는 기본 모드이다.
2. 멀티태스킹, 세그멘테이션, 페이징을 지원한다.   
3. 디바이스 드라이버를 써야 장치 제어가 가능하다.   
4. 4GB의 메모리 제한이 있다. (2^32)
5. 민감한 메모리 영역에 대한 보호를 제공한다.

이러한 특성을 하나하나 세부적으로 살펴보겠다.

## 1. 윈도우나 Linux가 구동되는 기본 모드이다.   
윈도우나 linux에서는 기본적으로 32bit OS부터 지원한다. 윈도우 DOS 시리즈의 시작인 Window 95가 x386가
최소사양이었고 x386은 32bit 아키텍처였다. linux의 경우도 마찬가지인게 처음 버전인 linux 0.01 version 역시
x386 아키텍처를 기반으로 하드코딩되어있다. 이 역시 32bit 아키텍처를 기반으로 설계된 것이다.
그렇기 때문에 윈도우나 Linux를 구동하기 위해서는 적어도 프로세서가 32bit 아키텍처를 지원해야한다는 뜻이다.
(물론 최근에는 임베디드가 아닌 범용 16bit 아키텍처를 구하는게 더 어렵긴하다)

## 2. 멀티태스킹, 세그멘테이션, 페이징을 지원한다.
이전에 리얼모드에서는 세그멘테이션만 지원했지만, 32bit 부터는 하드웨어적으로 페이징과 멀티태스킹을 지원한다.
페이징이랑 프로그램 구동에 필요한 코드를 특정한 크기로 잘라서 일부만 메모리에 올려서 구동하는 형태를 말하는데
이러한 페이징은 "모드에 대한 이해" 포스팅 이후에 함수 호출에 대한 언급이 있은 후 다시 포스팅할 예정이다.
멀티태스킹도 지원한다고 했는데 멀티 태스킹이라는 것은 여러 개의 job을 특정 time slice를 분배하여
번갈아가며 처리하는 기법을 말한다. 여기서 말하는 JOB은 프로세스 혹은 스레드로 이해하면 된다.
프로세스와 스레드의 차이는 차후 다시 설명하겠다.

## 3. 디바이스 드라이버를 써야 장치 제어가 가능하다.
디바이스 드라이버를 써야 장치 제어가 가능하다는 것은 정확하게 다시 말하자면 리얼 모드에서처럼 디바이스에 대한 직접적인
엑세스가 안되므로 이러한 디바이스에 대한 접근 및 제어를 요청해서 해당하는 반환값만 받아서 사용할 수 있는 것이다.
이러한 매개가 되는 것이 디바이스 드라이버이기 때문에 디바이스 드라이버를 써야 장치제어가 된다는 말이 그러한 뜻인 것이다.

## 4. 4GB의 메모리 제한이 있다. (2^32)
4GB의 메모리 제한이 있는 것은 당연한게 32bit 프로세서라는 것은 내부 버스도 32bit고 메모리 주소도 32bit 단위이기 때문에
2^32 = 4GB의 제한이 있다. 물론 예약된 메모리 부분을 제외하면 대충 4GB 좀 덜되는 정도이다.

## 5. 민감한 메모리 영역에 대한 보호를 제공한다.
민감한 메모리 영역에 대한 보호를 제공한다는 것은 리얼모드에서는 부트로더가 로딩 되는 위치나
예약된 메모리 영역에 접근도 가능했다 수정도 가능했다. 물론 잘못 수정하면 컴퓨터 동작이 안 하거나 문제가 생겼지만
어쨌든 가능했으며 멀티 태스킹도 안되는 상황이었기에 큰 문제가 되진 않았다.
하지만 32bit로 넘어오면서 민감한 메모리 영역에 대해 보호가 필요해졌다. 가령 TASK1과 2가 멀티 태스킹 되고 있는데
TASK1에서 TASK2의 메모리 영역을 침범하면 그건 문제가 되는 것이다. TASK1이 3이라고 계산한 데이터가 TASK2의 작업에
덮어씌워져서 2라고 되면 계산상에 오류가 날테니까 말이다. 그렇기에 인가되지 않은 메모리 영역 접근에 대한
룰이 생겼고 이러한 룰이 작동하는 방식에 대해서는 커널에 대한 설명을 하면서 추가적인 세부 설명이 들어갈 것이다.

### 참고 문헌
1. 64Bit 멀티코어 OS의 구조 - 한승훈 저
