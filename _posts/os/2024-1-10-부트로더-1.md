---
title: 부트로더 - 1
author: blakewoo
date: 2024-1-10 21:30:00 +0900
categories: [OS]
tags: [OS]
render_with_liquid: false
---

부트로더를 한줄로 정의하면 아래와 같다.
```
OS를 부팅하기 위해서 필요한 512Bytes 코드
```

이 문장을 해석하면 부트로더가 무엇인지 어떻게 구동되는지 알 수 있다.

컴퓨터가 켜지면 POST라는 절차를 거친다.
이 POST는 프로세서를 초기화하고, 메모리 검사 및 초기화를 한 뒤 주변 장치 검사 및 초기화를
하는 일련의 과정이다. 이 과정에서 CPU의 코어 개수나 기기 상태들을 확인하고 특정 메모리에 
기재해둔다. 이러한 일은 하는 것은 메인보드에 위치한 바이오스나 UEFI인데
이 부분은 멀티 코어에 대해서 논할때 추가적으로 언급하겠다.

아무튼 이 POST 절차를 거치고 나서 플로피디스크든, HDD든 SSD든 BootDevice로 지정된
저장장치의 제일 앞 512Bytes를 읽어서 메모리 0x7C00번지에 복사한다.
(굳이 512Bytes인 이유가 있다. HDD의 한 섹터 크기가 512Byets이기 때문이다.
만약에 SSD로 컴퓨터의 역사가 시작되었다면 크기가 달라졌을 수도 있다.)

이때 복사되는 512Bytes가 바로 부트로더라는 것이다.
이렇게 복사된 512Bytes는 이후에 바로 실행에 들어가게 된다.

이 512Bytes 코드가 하는 일은 매우 간단한데,
처음 구동하면 16bit 리얼모드로 컴퓨터가 구동된다. 한번에 16bit 크기의 범용 레지스터를 사용하고
디바이스에 직접 접근 가능한 모드이다. 32bit 모드인 보호 모드와 64bit이 IA-64 모드는
반대로 디바이스에 직접 접근은 안되고 한번에 각각 32, 64bit 크기의 범용 레지스터와 그에 비례하는
메모리를 사용할 수 있는 모드지만 차후 해당 부분에 대해선 세부적으로 설명을 하도록 하겠다.

이러한 16bit 리얼모드에서 512Bytes의 코드가 하는 일은
32bit kernel 코드를 긁어서 메모리에 복사해둔뒤
시스템 관련된 레지스터중에 컨트롤 레지스터에서 32bit용 모드로 넘어갈때 필요한 부분을 변경 한 뒤
다음에 실행할 프로그램 코드를 가르키는 PC(Program Counter)를 32Bit 보호 모드로 변경하여
32bit 커널 코드로 점프하는 것이다.

위의 절차만 봤을 때 몇 가지 의문이 들 수 있다.
가령 "그냥 512Bytes를 복사해오는 것 대신에 더 많은 코드를 복사해와서 모드를 변경하면 좋지 않나?"라던가
혹은 "512Bytes에서 바로 64bit 모드로 넘어가는게 더 좋지 않나?"하는 생각이다.

이건 하위 호환성을 유지하기 위해서이다. 실제로 32bit cpu는 16bit에 대한 호환성을 64bit cpu는
16bit와 32bit OS에 대한 호환성을 그대로 유지하고 있다.
이는 새로운 CPU에서도 이전 OS를 구동가능하게 하기 위한 것인데, 아무래도 하위 호환성의 여부가
시장의 CPU 점유율에 영향을 미칠 수 있기 때문이 아닐까 싶다.

다음은 부트로더에 대한 세부 코드 및 내용에 대해서 알아보겠다.

### 참고 문헌
1. 64Bit 멀티코어 OS의 구조 - 한승훈 저
