---
title: 32bit kernel - 2
author: blakewoo
date: 2024-2-29 23:05:00 +0900
categories: [OS]
tags: [OS]
render_with_liquid: false
---

# 페이징 및 세그멘테이션 설정
이전에 페이징과 세그멘테이션에 대한 포스팅을 진행한 적이 있다.
페이징과 세그멘테이션을 소프트웨어적인 방법으로 구현하여 사용할 수도 있겠지만 으레 그러하듯
하드웨어적으로 구현된 것 보단 성능이 떨어진다. 그렇기 때문에 아키텍처 자체에서
페이징과 세그멘테이션을 지원한다.

페이징과 세그멘테이션을 활성화하기 위해서 우리가 살펴봐야할 부분은 다름아닌 컨트롤 레지스터이다.

## 페이징과 보호 모드 확성화를 위한 컨트롤 레지스터에 대한 세부 명세
해당 레지스터에 대한 간단한 내용은 이미 이전에 하드웨어에 대한 구조 6에서 다루었었다.
하지만 여기서 필요한건 페이징과 세그멘테이션, 그리고 보호 모드로 넘어가기 위한 설정이 필요한 것이다.
아래의 표를 보자, 이 표는 컨트롤 레지스터중 운영 모드와 페이징을 담당하는 컨트롤 레지스터인
CR0의 구조이다. 해당 부분 중에서 페이징과 보호모드에 관여하는 비트 딱 두 개만 살펴보도록 하겠다.

![img.png](/assets/blog/os/2024/cr0_control_register.png)

### PE
Protected enabled의 약자로 보호모드를 활성화 할 것인지 나타내는 비트이며 1이면 보호 모드
0이면 리얼모드로 진입한다.

### PG
Paging의 약자이며 페이지 기능을 활성화 할 것인지 아닌지를 나타내며 1이면 페이징 사용
0이면 페이징을 사용하지 않는 것이다.

데이터를 로드한 후 CR0의 두 비트를 설정한 뒤 해당 데이터로 JMP하게 되면 보호모드가 시작되는 것이다.

# 참고 문헌
1. 64Bit 멀티코어 OS의 구조 - 한승훈 저
2. Intel® 64 and IA-32 Architectures
   Software Developer’s Manual
   Volume 3A:
   System Programming Guide, Part 1
   
# 업데이트
- 20240302 : 데이터 중복 제거
