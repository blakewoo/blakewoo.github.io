---
title: C++ - 예외처리
author: blakewoo
date: 2025-7-19 20:00:00 +0900
categories: [C++]
tags: [C++, try catch] 
render_with_liquid: false
use_math: true
---

# C++ 예외처리
## 1. 개요
C++의 예외 처리(Exception Handling)는 프로그램 실행 중 발생할 수 있는 오류(예외 상황)를 분리하고,
이를 포괄적이고 안전하게 다루기 위한 메커니즘이다.
전통적인 오류 코드는 반환값이나 전역 변수로 처리하지만,
예외 처리를 이용하면 오류 발생 지점을 호출 지점으로 강제 전파하고, 
집중된 위치에서 일괄 처리할 수 있어 코드 가독성과 안전성이 향상된다.

## 2. 기본적인 처리 (try, catch, throw)
아래 예시는 0으로 나누었을 때 예외처리이다.

```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 0) << "\n";
    }
    catch (const std::runtime_error& e) {
        std::cerr << "Runtime error: " << e.what() << "\n";
    }
    catch (const std::exception& e) {
        // std::runtime_error 외 다른 std 예외
        std::cerr << "Exception: " << e.what() << "\n";
    }
    catch (...) {
        // 그 외 모든 예외
        std::cerr << "Unknown exception caught\n";
    }
    return 0;
}
```

- throw: 예외 상황이 발생한 지점에서 값을 던진다.
- try: 예외 발생 가능 코드 블록을 감싼다.
- catch: throw된 예외를 형식에 맞춰 잡아 처리한다.
- catch(...): 그외 어떤 타입의 예외든 잡아낸다.


## 3. 표준 예외 계층 구조
c++ 에서 표준 라이브러리의 예외 계층 구조는 아래와 같다.

```
std::exception
├─ std::bad_alloc
├─ std::bad_cast
├─ std::bad_typeid
├─ std::bad_exception
├─ std::logic_error
│   ├─ std::domain_error
│   ├─ std::invalid_argument
│   ├─ std::length_error
│   └─ std::out_of_range
└─ std::runtime_error
    ├─ std::overflow_error
    ├─ std::underflow_error
    └─ std::range_error
```
- std::bad_alloc
발생 시점: new 연산자가 메모리 할당에 실패했을 때
헤더: \<new\>   
설명: 시스템 메모리가 부족하거나 할당 요청이 너무 클 때 던져지며, e.what()은 일반적으로 "std::bad_alloc"을 반환한다.

- std::bad_cast   
발생 시점: dynamic_cast<Derived&>(base_ref)처럼 레퍼런스 기반 캐스트가 실패했을 때   
헤더: \<typeinfo\>
설명: 다운 캐스트나 횡단적 캐스트가 정확히 일치하지 않을 때 발생하며, 레퍼런스 캐스트만 예외를 던지고 포인터 캐스트(dynamic_cast<Derived*>(base_ptr))는 nullptr을 반환한다.

- std::bad_typeid   
발생 시점: typeid(*ptr)에서 ptr이 nullptr일 때
헤더: \<typeinfo\>    
설명: 런타임에 타입 정보를 얻을 수 없을 때 발생하며, 마찬가지로 e.what()은 "std::bad_typeid"를 반환한다.

- std::bad_exception    
발생 시점: 함수 선언부의 예외 사양(exception specification)에 명시되지 않은 예외를 던질 때   
헤더: \<exception\>
설명: C++17부터는 거의 사용되지 않는 기능이지만(예외 사양은 deprecated), 만약 void f() throw(int); 같이 선언된 함수가 int 이외 타입의 예외를 던지면 std::bad_exception으로 변환되어 전파된다.    

- std::logic_error    
발생 시점: 프로그래머의 논리적 실수나 계약(precondition) 위반이 감지될 때   
헤더: \<stdexcept\>
설명: 함수가 요구하는 조건(예: 인자의 유효 범위, 상태 머신의 올바른 상태 등)이 지켜지지 않았을 때 던져진다. throw std::logic_error("Invalid argument");처럼 메시지를 직접 지정할 수 있으며, e.what()은 해당 메시지를 반환한다.

- std::runtime_error
발생 시점: 실행 중 환경 의존적 오류가 발생했을 때    
헤더: \<stdexcept\>    
설명: 파일 I/O 실패, 네트워크 오류, 메모리 부족 등 런타임 상황에서 복구할 수 없는 문제가 생기면 던져진다. 예를 들어 throw std::runtime_error("File open failed");처럼 사용하며, e.what()은 지정된 설명 문자열을 반환한다.

> ※ 추가 업데이트 예정
{: .prompt-tip }

# 참고자료
- [위키독스 - C++ 이야기](https://wikidocs.net/25044)
- [c++20 공식문서](https://isocpp.org/files/papers/N4860.pdf)
