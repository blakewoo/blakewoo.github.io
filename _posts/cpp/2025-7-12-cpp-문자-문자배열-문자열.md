---
title: C++ - 문자, 문자배열, 문자열
author: blakewoo
date: 2025-7-12 23:00:00 +0900
categories: [C++]
tags: [C++] 
render_with_liquid: false
use_math: true
---

# C++ 문자, 문자배열, 문자열
## 1. 문자
기본적으로 아스키코드 문자라면 1개당 1byte를 요한다. 인터넷 웹페이지에서 사용하는 UTF-8은 영문의 경우 1byte이고   
한글이나 한자는 3byte이다. 한글 문자 인코딩 표준은 KS X 1001, EUC-KR에 따라 2byte 문자로 처리된다. 그래서 만약
한국어 문자를 입력하고 싶다면 char 형으로는 2개가 필요하다.

이렇게 되니 어떨때는 1byte char로 처리되고 어떨때는 2bytes가 필요하니 등장한 자료형이 wchar_t이고 이 자료형은
리눅스(GCC)에서 빌드될때는 4Bytes이고, 윈도우(MSVC)에서 빌드 되면 2Bytes크기이다.

```cpp
char a = 'a' // 1bytes 차지
wchar_t = '김' // 리눅스에서 4Bytes, 윈도우에서 2Bytes
```

wchar_t를 출력시 locale 처리를 해주어야하는데, 이는 컴파일러에 따라서 각각 다르며 g++이나 visual studio별로 다르다.

### 1) 리눅스 예시

```cpp
#include <iostream>
#include <locale>
#include <string>
#include <clocale>
#include <codecvt>        // deprecated in C++17+, but used here for brevity
#include <iostream>

int main() {
    // 1) 로케일을 환경 로케일로 설정 (예: en_US.UTF-8)
    std::setlocale(LC_ALL, "");
    std::locale::global(std::locale(""));
    std::wcout.imbue(std::locale());

    // 2) UTF-8 바이트 문자열 (소스 파일이 UTF-8로 저장되어 있어야 함)
    std::string utf8 = u8"안녕, 세상아!";

    // 3) UTF-8 -> std::wstring 변환 (주의: codecvt는 deprecated)
    std::wstring_convert<std::codecvt_utf8<wchar_t>> conv;
    std::wstring ws = conv.from_bytes(utf8);

    // 4) 출력
    std::wcout << ws << L"\n";
    return 0;
}
```

### 2) 윈도우 예시

```cpp
#include <windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <io.h>
#include <fcntl.h>

// UTF-8 -> UTF-16 (std::wstring) 변환 (Windows API)
std::wstring utf8_to_wstring(const std::string &s) {
    if (s.empty()) return {};
    int needed = MultiByteToWideChar(CP_UTF8, 0, s.data(), (int)s.size(), nullptr, 0);
    std::wstring out;
    out.resize(needed);
    MultiByteToWideChar(CP_UTF8, 0, s.data(), (int)s.size(), &out[0], needed);
    return out;
}

int main() {
    // 1) 콘솔을 UTF-16 출력 모드로 설정 -> wcout으로 한글/UTF-16 출력 가능
    _setmode(_fileno(stdout), _O_U16TEXT);

    // 2) UTF-8 소스 리터럴 (소스가 UTF-8로 저장되어 있어야 함)
    std::string utf8 = u8"안녕, 세상아!";

    // 3) 변환 및 출력
    std::wstring ws = utf8_to_wstring(utf8);
    std::wcout << ws << L"\n";

    return 0;
}
```


## 2. 문자배열
전통적인 C 형식의 문자열을 보관하는 배열이다. 끝에는 NULL값이 포함되어있는 형태이다.

```cpp
char strArray[6] =  { 'A', 'B', 'C', 'D', 'E', NULL };
```

항상 끝에 NULL이 들어가기 때문에 실제 사용하는 문자 개수보다 한 개 더 크기를 잡아주어야한다.
아예 문자열로 지정해버리면 해당 배열의 크기를 지정해주지 않아도 알아서 잡아준다.

```cpp
char strArrayLazy[] = "abcedfg";
```

위와 같은 경우 문자 개수의 크기는 7개지만 실제 배열의 크기는 8이다.

## 3. 문자열
c++98부터 지원하는 자료형으로 헤더파일을 <string> 혹은 <iostream>를 추가해서 사용한다.
(<iosteam>는 입출력 헤더지만 기본적으로 string에 대한 내용이 포함되어있다)

위의 문자 배열의 경우 끝에 NULL값이 포함되어있지만, 해당 string 타입의 경우에는 NULL값이 포함되어있지 않으며
primitive type은 아니지만 그냥 기본 자료형 쓰듯이 사용하면 된다.

```cpp
include<string>
using namespace std;

string Str = "ABCDE";              // "ABCDE"로 초기화
string Str2;                       // 빈 문자열
string Str3("Hello");              // C-스트링으로부터
string Str4(s2);                   // 복사 생성
string Str5(5, 'A');               // 'A' 문자를 5개로 초기화 → "AAAAA"

```

만약 해당 Str 값을 함수 인자로 넣게 되면 해당 값을 모두 복사하기 때문에 성능상의 이슈가 있을 수 있다.   
때문에 C++에서는 상수형 string에 대해서는 바로 갖다 쓸 수 있게 std::string_view 라는 자료형을 지원한다.

```cpp
#include <iostream>
#include <string_view>
#include <typeinfo>

using namespace std;

void printStr(std::string_view str)
{
    cout << str << endl;
}

int main()
{
    string str = "Hello world!";
    printStr(str);
    return 0;
}
```

### ※ 문자열 처리 함수
string 클래스는 내부적으로 지원하는 함수가 매우 많은데 아래는 그 함수들의 예시이다.

#### 1) 사이즈와 용량에 대한 함수
```cpp
string s2 = "test";
s2.size();       // 문자열 길이 (elements 수)
s2.length();     // size()와 동일
s2.empty();      // 비어 있으면 true
s2.capacity();   // 내부적으로 할당된 메모리 크기
s2.reserve(100); // 최소 용량을 100으로 조정
s2.shrink_to_fit(); // 여유 용량을 제거
```

#### 2) 값 가져오기
```cpp
char c1 = s2[0];        // 경계 검사 없음
char c2 = s2.at(1);     // 경계 검사 후 예외(std::out_of_range) 발생 가능
char& c3 = s2.front();  // 첫 문자 (빈 문자열이면 정의되지 않음)
char& c4 = s2.back();   // 마지막 문자
```

#### 3) 문자열 연결 및 삽입
```cpp
string a = "Hi, ";
string b = "World!";
string c = a + b;           // "Hi, World!"
a += b;                     // a = "Hi, World!"
a.append("!!!");            // a = "Hi, World!!!!"
a.insert(3, " there");      // a = "Hi there, World!!!!"
```

#### 4) 부분 문자열
```cpp
string t = "abcdefg";
string sub = t.substr(2, 3); // 시작 인덱스 2에서 길이 3 → "cde"
```

#### 5) 탐색
```cpp
string t = "abcdefg";
size_t pos1 = t.find("cd");  // "cd"가 처음 나오는 위치 (2), 못 찾으면 npos
size_t pos2 = t.rfind('g');  // 뒤에서부터 탐색 (결과 6)
```

#### 6) 비교
```cpp
string x = "apple", y = "banana";
int cmp = x.compare(y);      // <0: x<y, 0: 같음, >0: x>y
// 부분 비교: x.compare(pos, len, y)
```

#### 7) 수정
```cpp
string t = "abcedfg";
t.replace(2, 3, "XYZ");   // 인덱스 2부터 3글자를 "XYZ"로 교체 → "abXYZfg"
t.erase(0, 2);            // 인덱스 0부터 2글자 삭제       → "XYZfg"
t.clear();                // 전체 내용 삭제 (빈 문자열)
```

# 참고자료
- [위키독스 - C++ 이야기](https://wikidocs.net/25044)
- [c++20 공식문서](https://isocpp.org/files/papers/N4860.pdf)
- [microsoft - 범위기반 for문(C++)](https://learn.microsoft.com/ko-kr/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)
- [cppreference - Fundamental types(wchar_t)](https://en.cppreference.com/w/cpp/language/types.html#Character_types)
